<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android多线程断点续传下载]]></title>
      <url>%2F2017%2F01%2F17%2FAndroid%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[原理其实断点续传的原理很简单，从字面上理解，所谓断点续传就是从停止的地方重新下载。断点：线程停止的位置。续传：从停止的位置重新下载。用代码解析就是：断点：当前线程已经下载完成的数据长度。续传：向服务器请求上次线程停止位置之后的数据。原理知道了，功能实现起来也简单。每当线程停止时就把已下载的数据长度写入记录文件，当重新下载时，从记录文件读取已经下载了的长度。而这个长度就是所需要的断点。续传的实现也简单，可以通过设置网络请求参数，请求服务器从指定的位置开始读取数据。而要实现这两个功能只需要使用到httpURLconnection里面的setRequestProperty方法便可以实现.1public void setRequestProperty(String field, String newValue) 如下所示，便是向服务器请求500-1000之间的500个byte：1conn.setRequestProperty("Range", "bytes=" + 500 + "-" + 1000); 以上只是续传的一部分需求，当我们获取到下载数据时，还需要将数据写入文件，而普通发File对象并不提供从指定位置写入数据的功能，这个时候，就需要使用到RandomAccessFile来实现从指定位置给文件写入数据的功能。1public void seek(long offset) 如下所示，便是从文件的的第100个byte后开始写入数据。1raFile.seek(100); 而开始写入数据时还需要用到RandomAccessFile里面的另外一个方法1public void write(byte[] buffer, int byteOffset, int byteCount) 该方法的使用和OutputStream的write的使用一模一样… 以上便是断点续传的原理。 多线程断点续传而多线程断点续传便是在单线程的断点续传上延伸的，而多线程断点续传是把整个文件分割成几个部分，每个部分由一条线程执行下载，而每一条下载线程都要实现断点续传功能。为了实现文件分割功能，我们需要使用到httpURLconnection的另外一个方法：1public int getContentLength() 当请求成功时，可以通过该方法获取到文件的总长度。每一条线程下载大小 = fileLength / THREAD_NUM 如下图所示，描述的便是多线程的下载模型：在多线程断点续传下载中，有一点需要特别注意：由于文件是分成多个部分是被不同的线程的同时下载的，这就需要，每一条线程都分别需要有一个断点记录，和一个线程完成状态的记录；如下图所示：只有所有线程的下载状态都处于完成状态时，才能表示文件已经下载完成。实现记录的方法多种多样，我这里采用的是JDK自带的Properties类来记录下载参数。 断点续传结构通过原理的了解，便可以很快的设计出断点续传工具类的基本结构图 IDownloadListener.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.arialyy.frame.http.inf;import java.net.HttpURLConnection;/** * 在这里面编写你的业务逻辑 */public interface IDownloadListener &#123; /** * 取消下载 */ public void onCancel(); /** * 下载失败 */ public void onFail(); /** * 下载预处理,可通过HttpURLConnection获取文件长度 */ public void onPreDownload(HttpURLConnection connection); /** * 下载监听 */ public void onProgress(long currentLocation); /** * 单一线程的结束位置 */ public void onChildComplete(long finishLocation); /** * 开始 */ public void onStart(long startLocation); /** * 子程恢复下载的位置 */ public void onChildResume(long resumeLocation); /** * 恢复位置 */ public void onResume(long resumeLocation); /** * 停止 */ public void onStop(long stopLocation); /** * 下载完成 */ public void onComplete();&#125; 该类是下载监听接口 DownloadListener.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.net.HttpURLConnection;/** * 下载监听 */public class DownloadListener implements IDownloadListener &#123; @Override public void onResume(long resumeLocation) &#123; &#125; @Override public void onCancel() &#123; &#125; @Override public void onFail() &#123; &#125; @Override public void onPreDownload(HttpURLConnection connection) &#123; &#125; @Override public void onProgress(long currentLocation) &#123; &#125; @Override public void onChildComplete(long finishLocation) &#123; &#125; @Override public void onStart(long startLocation) &#123; &#125; @Override public void onChildResume(long resumeLocation) &#123; &#125; @Override public void onStop(long stopLocation) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125; 下载参数实体12345678910111213141516171819202122232425262728/** * 子线程下载信息类 */private class DownloadEntity &#123; //文件总长度 long fileSize; //下载链接 String downloadUrl; //线程Id int threadId; //起始下载位置 long startLocation; //结束下载的文章 long endLocation; //下载文件 File tempFile; Context context; public DownloadEntity(Context context, long fileSize, String downloadUrl, File file, int threadId, long startLocation, long endLocation) &#123; this.fileSize = fileSize; this.downloadUrl = downloadUrl; this.tempFile = file; this.threadId = threadId; this.startLocation = startLocation; this.endLocation = endLocation; this.context = context; &#125;&#125; 该类是下载信息配置类，每一条子线程的下载都需要一个下载实体来配置下载信息。 下载任务线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * 多线程下载任务类 */private class DownLoadTask implements Runnable &#123; private static final String TAG = "DownLoadTask"; private DownloadEntity dEntity; private String configFPath; public DownLoadTask(DownloadEntity downloadInfo) &#123; this.dEntity = downloadInfo; configFPath = dEntity.context.getFilesDir().getPath() + "/temp/" + dEntity.tempFile.getName() + ".properties"; &#125; @Override public void run() &#123; try &#123; L.d(TAG, "线程_" + dEntity.threadId + "_正在下载【" + "开始位置 : " + dEntity.startLocation + "，结束位置：" + dEntity.endLocation + "】"); URL url = new URL(dEntity.downloadUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //在头里面请求下载开始位置和结束位置 conn.setRequestProperty("Range", "bytes=" + dEntity.startLocation + "-" + dEntity.endLocation); conn.setRequestMethod("GET"); conn.setRequestProperty("Charset", "UTF-8"); conn.setConnectTimeout(TIME_OUT); conn.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.2; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)"); conn.setRequestProperty("Accept", "image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave-flash, application/xaml+xml, application/vnd.ms-xpsdocument, application/x-ms-xbap, application/x-ms-application, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*"); conn.setReadTimeout(2000); //设置读取流的等待时间,必须设置该参数 InputStream is = conn.getInputStream(); //创建可设置位置的文件 RandomAccessFile file = new RandomAccessFile(dEntity.tempFile, "rwd"); //设置每条线程写入文件的位置 file.seek(dEntity.startLocation); byte[] buffer = new byte[1024]; int len; //当前子线程的下载位置 long currentLocation = dEntity.startLocation; while ((len = is.read(buffer)) != -1) &#123; if (isCancel) &#123; L.d(TAG, "++++++++++ thread_" + dEntity.threadId + "_cancel ++++++++++"); break; &#125; if (isStop) &#123; break; &#125; //把下载数据数据写入文件 file.write(buffer, 0, len); synchronized (DownLoadUtil.this) &#123; mCurrentLocation += len; mListener.onProgress(mCurrentLocation); &#125; currentLocation += len; &#125; file.close(); is.close(); if (isCancel) &#123; synchronized (DownLoadUtil.this) &#123; mCancelNum++; if (mCancelNum == THREAD_NUM) &#123; File configFile = new File(configFPath); if (configFile.exists()) &#123; configFile.delete(); &#125; if (dEntity.tempFile.exists()) &#123; dEntity.tempFile.delete(); &#125; L.d(TAG, "++++++++++++++++ onCancel +++++++++++++++++"); isDownloading = false; mListener.onCancel(); System.gc(); &#125; &#125; return; &#125; //停止状态不需要删除记录文件 if (isStop) &#123; synchronized (DownLoadUtil.this) &#123; mStopNum++; String location = String.valueOf(currentLocation); L.i(TAG, "thread_" + dEntity.threadId + "_stop, stop location ==&gt; " + currentLocation); writeConfig(dEntity.tempFile.getName() + "_record_" + dEntity.threadId, location); if (mStopNum == THREAD_NUM) &#123; L.d(TAG, "++++++++++++++++ onStop +++++++++++++++++"); isDownloading = false; mListener.onStop(mCurrentLocation); System.gc(); &#125; &#125; return; &#125; L.i(TAG, "线程【" + dEntity.threadId + "】下载完毕"); writeConfig(dEntity.tempFile.getName() + "_state_" + dEntity.threadId, 1 + ""); mListener.onChildComplete(dEntity.endLocation); mCompleteThreadNum++; if (mCompleteThreadNum == THREAD_NUM) &#123; File configFile = new File(configFPath); if (configFile.exists()) &#123; configFile.delete(); &#125; mListener.onComplete(); isDownloading = false; System.gc(); &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); isDownloading = false; mListener.onFail(); &#125; catch (IOException e) &#123; FL.e(this, "下载失败【" + dEntity.downloadUrl + "】" + FL.getPrintException(e)); isDownloading = false; mListener.onFail(); &#125; catch (Exception e) &#123; FL.e(this, "获取流失败" + FL.getPrintException(e)); isDownloading = false; mListener.onFail(); &#125; &#125; 这个是每条下载子线程的下载任务类，子线程通过下载实体对每一条线程进行下载配置，由于在多断点续传的概念里，停止表示的是暂停状态，而恢复表示的是线程从记录的断点重新进行下载，所以，线程处于停止状态时是不能删除记录文件的。 下载入口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * 多线程断点续传下载文件，暂停和继续 * * @param context 必须添加该参数，不能使用全局变量的context * @param downloadUrl 下载路径 * @param filePath 保存路径 * @param downloadListener 下载进度监听 &#123;@link DownloadListener&#125; */public void download(final Context context, @NonNull final String downloadUrl, @NonNull final String filePath, @NonNull final DownloadListener downloadListener) &#123; isDownloading = true; mCurrentLocation = 0; isStop = false; isCancel = false; mCancelNum = 0; mStopNum = 0; final File dFile = new File(filePath); //读取已完成的线程数 final File configFile = new File(context.getFilesDir().getPath() + "/temp/" + dFile.getName() + ".properties"); try &#123; if (!configFile.exists()) &#123; //记录文件被删除，则重新下载 newTask = true; FileUtil.createFile(configFile.getPath()); &#125; else &#123; newTask = false; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); mListener.onFail(); return; &#125; newTask = !dFile.exists(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; mListener = downloadListener; URL url = new URL(downloadUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod("GET"); conn.setRequestProperty("Charset", "UTF-8"); conn.setConnectTimeout(TIME_OUT); conn.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.2; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)"); conn.setRequestProperty("Accept", "image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave-flash, application/xaml+xml, application/vnd.ms-xpsdocument, application/x-ms-xbap, application/x-ms-application, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*"); conn.connect(); int len = conn.getContentLength(); if (len &lt; 0) &#123; //网络被劫持时会出现这个问题 mListener.onFail(); return; &#125; int code = conn.getResponseCode(); if (code == 200) &#123; int fileLength = conn.getContentLength(); //必须建一个文件 FileUtil.createFile(filePath); RandomAccessFile file = new RandomAccessFile(filePath, "rwd"); //设置文件长度 file.setLength(fileLength); mListener.onPreDownload(conn); //分配每条线程的下载区间 Properties pro = null; pro = Util.loadConfig(configFile); int blockSize = fileLength / THREAD_NUM; SparseArray&lt;Thread&gt; tasks = new SparseArray&lt;&gt;(); for (int i = 0; i &lt; THREAD_NUM; i++) &#123; long startL = i * blockSize, endL = (i + 1) * blockSize; Object state = pro.getProperty(dFile.getName() + "_state_" + i); if (state != null &amp;&amp; Integer.parseInt(state + "") == 1) &#123; //该线程已经完成 mCurrentLocation += endL - startL; L.d(TAG, "++++++++++ 线程_" + i + "_已经下载完成 ++++++++++"); mCompleteThreadNum++; if (mCompleteThreadNum == THREAD_NUM) &#123; if (configFile.exists()) &#123; configFile.delete(); &#125; mListener.onComplete(); isDownloading = false; System.gc(); return; &#125; continue; &#125; //分配下载位置 Object record = pro.getProperty(dFile.getName() + "_record_" + i); if (!newTask &amp;&amp; record != null &amp;&amp; Long.parseLong(record + "") &gt; 0) &#123; //如果有记录，则恢复下载 Long r = Long.parseLong(record + ""); mCurrentLocation += r - startL; L.d(TAG, "++++++++++ 线程_" + i + "_恢复下载 ++++++++++"); mListener.onChildResume(r); startL = r; &#125; if (i == (THREAD_NUM - 1)) &#123; endL = fileLength;//如果整个文件的大小不为线程个数的整数倍，则最后一个线程的结束位置即为文件的总长度 &#125; DownloadEntity entity = new DownloadEntity(context, fileLength, downloadUrl, dFile, i, startL, endL); DownLoadTask task = new DownLoadTask(entity); tasks.put(i, new Thread(task)); &#125; if (mCurrentLocation &gt; 0) &#123; mListener.onResume(mCurrentLocation); &#125; else &#123; mListener.onStart(mCurrentLocation); &#125; for (int i = 0, count = tasks.size(); i &lt; count; i++) &#123; Thread task = tasks.get(i); if (task != null) &#123; task.start(); &#125; &#125; &#125; else &#123; FL.e(TAG, "下载失败，返回码：" + code); isDownloading = false; System.gc(); mListener.onFail(); &#125; &#125; catch (IOException e) &#123; FL.e(this, "下载失败【downloadUrl:" + downloadUrl + "】\n【filePath:" + filePath + "】" + FL.getPrintException(e)); isDownloading = false; mListener.onFail(); &#125; &#125; &#125;).start();&#125; 其实也没啥好说的，注释已经很完整了，需要注意两点1、恢复下载时：已下载的文件大小 = 该线程的上一次断点的位置 - 该线程起始下载位置；2、为了保证下载文件的完整性，只要记录文件不存在就需要重新进行下载； 最终效果 Demo点我]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在github上创建个人博客，其实没有那么难]]></title>
      <url>%2F2017%2F01%2F15%2F%E5%9C%A8github%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%85%B6%E5%AE%9E%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B9%88%E9%9A%BE%2F</url>
      <content type="text"><![CDATA[成功搭建的hexo网站 前段时间萌发自己搭建博客的念头，冲动之下买了个云服务器，奈何个人对html的东西实在不通，折腾了几天，blog依然丑的可以。后来无意间看见在github上可以搭建个人blog，就用谷歌折腾该如何在github上搭建blog，奈何网上很多教程都过于古老，或者很多细节都含糊不清，导致爬了好几天几天坑，才把blog搭建了起来。 如何在github上搭建blog 本文分为三个部分: 本地环境搭建 github 部署 hexo 与github关联 需要的的原料 git github 账号 node js hexo 个人域名(可选) 本地环境搭建 安装git 1https://www.git-scm.com/download/win 选择你需要的版本，一路默认安装便可 安装node js 32位下载地址 1https://nodejs.org/dist/v4.2.3/node-v4.2.3-x86.msi 64位下载地址 1https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi 下载完成后双击安装，不做任何操作，一直默认下去便可。 安装完成后win+R调出CMD命令，输入node -v，校验是否安装成功，如果出现以下信息，则表示安装成功 安装完成node js后，在任意目录下打开cmd命令窗口，输入以下命令来安装hexo 1npm install -g hexo 如果出现以下信息，则表示hexo安装成功 接着输入以下命令添加git依赖注意： 该命令必须在hexo g 之前完成 部署这个命令一定要用git bash，否则会提示Permission denied (publickey). 1npm install hexo-deployer-git --save 如果出现以下信息，则表示hexo git依赖安装成功 创建hexo工程在任意盘符中创建一个文件夹，把它命名为hexo，打开该文件夹，在该目录下打开cmd，输入以下命令 1hexo init hexo 便自动创建了一个项目，目录结构如下: 现在在cmd命令下输入以下命令 1hexo server -p 5001 如果出现以下信息，表示你已经生成了hexo工程。现在，是时候在浏览器中展示你的成果了，在浏览器地址栏中，输入以下地址，如果出现以下页面，该页面便是你以后的blog的预览效果。 1http://localhost:5001/ github部署如果以上的网页能正常显示，那么恭喜你，本地环境搭建已经基本完成，现在是时候将hexo部署到github上了，将hexo部署你还需要完成几个步骤： 创建一个github账号 创建一个新的软件仓库，名称格式必须为：github的用户名.github.io。如：我的github用户名为：AriaLyy，那么该软件仓库的名必须为: AriaLyy.github.io最终软件仓库如下： 现在点击Settings，往下拉，如果你看见下图的信息 Your site is published at http://AriaLyy.github.io/只要出现可以点击的网络地址，那么表示github已经成功帮你自动生成一个静态网站了。 创建github ssk公钥在任意目录打开CMD，输入以下命令创建git ssh公钥，一路回车下去便可 1ssh-keygen -t rsa -C &quot;key_name&quot; 接着讲ssh公钥添加到github中。ps:如果你碰到ssh-keygen不是内部命令，那么你需要将git安装目录下的Git\usr\bin路径设置在环境变量中。 hexo 已github关联如果你已经完成了以上的步骤，那么你离成功只剩下一步之遥。还记得我们的hexo工程，以及*.github.io的软件仓吗？打开该文件，找到_config.yml文件，用文本编辑器打开，找到deploy字段，添加以下信息1234deploy: type: git repository: git@github.com:AriaLyy/AriaLyy.github.io.git # 这个配置为你*.github.io软件仓库clone地址 branch: master #分支为master分支 这里有几点需要注意： 每个参数，冒号后面，必须要有一个空格！！！！！！ repository 参数需要 ssh 的clone地址 branch 分支需要是master分支 如果你已经配置好以上步骤，接下来在hexo文件夹下打开cmd，输入以下命令，将hexo工程部署到github上。1hexo d -g 注意：部署这个命令一定要用git bash如果一切顺利，那么将会出现类似于下面的成功提示信息 那么在浏览器地址上输入:你的*.github.io软件仓库的名称，将会打开你的blog。 如果一切顺利，请尽情享受你的喜悦吧。 这是我在github上创建的个人blog，点击我]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从commit一步步带你走向fragment的生命周期]]></title>
      <url>%2F2017%2F01%2F13%2F%E4%BB%8Ecommit%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%B8%A6%E4%BD%A0%E8%B5%B0%E5%90%91fragment%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[Fragment 是android开发中最常用的组件之一，用了好几年，我都不知道Fragment到底是个什么东西，Activity加载Fragment的原理是怎样的，为什么官方会叫它为碎片？直到前段时间因为工作需要，从头看来一遍Fragment的源代码，然后就有了本文。本文将从commit开始一步步带你走向Fragmnt的生命周期！！ 经典的Frgment加载从最经典的Activity加载Fragment的流程说起，如下所示，是Activity加载Frgment的例子代码。12345678&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;FrameLayout android:id="@+id/content" android:layout_weight="1" android:layout_width="0px" android:layout_height="match_parent" android:background="?android:attr/detailsElementBackground" /&gt;&lt;/LinearLayout&gt; 123456789101112public static class DetailsActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (savedInstanceState == null) &#123; // During initial setup, plug in the details fragment. DetailsFragment details = new DetailsFragment(); details.setArguments(getIntent().getExtras()); getFragmentManager().beginTransaction().replace(R.id.content, details).commit(); &#125; &#125;&#125; Activity是通过getFragmentManager().beginTransaction()来进行加载Fragment的，我们就从这句话开始吧！fragment状态的切换时通过beginTransaction()方法来实现的，而beginTransaction()是FragmentManager的抽象方法，而FragmentManager真正的实现是FragamentManager的内部类FragmentManagerImpl，因此在FragmentManagerImpl中查找beginTransaction方法，最终方法发现beginTransaction真正生成的实例是BackStackRecord。 1234@Overridepublic FragmentTransaction beginTransaction() &#123; return new BackStackRecord(this);&#125; 由此可以知道replace，add，hide，show等等对Fragment状态的操作的真正实现都是在BackStackRecord的对应方法中实现，再看BackStackRecord的replace、add方法最终都会跳转到doAddOP1234567891011121314151617181920212223242526private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123; fragment.mFragmentManager = mManager; if (tag != null) &#123; if (fragment.mTag != null &amp;&amp; !tag.equals(fragment.mTag)) &#123; throw new IllegalStateException("Can't change tag of fragment " + fragment + ": was " + fragment.mTag + " now " + tag); &#125; fragment.mTag = tag; &#125; if (containerViewId != 0) &#123; if (fragment.mFragmentId != 0 &amp;&amp; fragment.mFragmentId != containerViewId) &#123; throw new IllegalStateException("Can't change container ID of fragment " + fragment + ": was " + fragment.mFragmentId + " now " + containerViewId); &#125; fragment.mContainerId = fragment.mFragmentId = containerViewId; &#125; Op op = new Op(); op.cmd = opcmd; op.fragment = fragment; addOp(op); &#125; 上面的代码中最核心的部分是最后的四行，可以看到内次replace都会new一个Op，那么OP到底是个什么东西？1234567891011static final class Op &#123; Op next; Op prev; int cmd; Fragment fragment; int enterAnim; int exitAnim; int popEnterAnim; int popExitAnim; ArrayList&lt;Fragment&gt; removed;&#125; 这是OP的源代码，可以看到OP有next和prev的字段，这两个字段的属性都是Op本身，并且它本身还有一些自带的属性，到现在依然不知道这个Op到底是什么，继续看addOp方法1234567891011121314void addOp(Op op) &#123; if (mHead == null) &#123; mHead = mTail = op; &#125; else &#123; op.prev = mTail; mTail.next = op; mTail = op; &#125; op.enterAnim = mEnterAnim; op.exitAnim = mExitAnim; op.popEnterAnim = mPopEnterAnim; op.popExitAnim = mPopExitAnim; mNumOp++;&#125; 从if-else语句中，再结合Op的结构，可以看出Op是一个双向链表，而addOp方法的作用是将replce生成的Op添加到当前链表中，到现在我们已经知道Op是个双向链表了，如下图所示： 那么Op到底有什么用，从目前看到的源码来看我们还是不知道。继续看BackStackRecord的show、remove等方法。1234567891011121314151617181920212223242526public FragmentTransaction remove(Fragment fragment) &#123; Op op = new Op(); op.cmd = OP_REMOVE; op.fragment = fragment; addOp(op); return this;&#125;public FragmentTransaction hide(Fragment fragment) &#123; Op op = new Op(); op.cmd = OP_HIDE; op.fragment = fragment; addOp(op); return this;&#125;public FragmentTransaction show(Fragment fragment) &#123; Op op = new Op(); op.cmd = OP_SHOW; op.fragment = fragment; addOp(op); return this;&#125; 从上面的代码看出，无论是replcae、add还是remove、hide、show操作，都会new一个Op并加到链表中，而每次添加链表时，Op的cmd和fragment都不一样，因此可以猜测Op链表实质上是操作fragment的命令链表，而执行命令的操作由commit等方法来完成的继续看BackStackRecord的commit方法，在前面我们猜测fragment状态的控制是由这个方法完成的。12345678910111213141516171819202122232425public int commit() &#123; return commitInternal(false);&#125;public int commitAllowingStateLoss() &#123; return commitInternal(true);&#125;int commitInternal(boolean allowStateLoss) &#123; if (mCommitted) throw new IllegalStateException("commit already called"); if (FragmentManagerImpl.DEBUG) &#123; Log.v(TAG, "Commit: " + this); LogWriter logw = new LogWriter(TAG); PrintWriter pw = new PrintWriter(logw); dump(" ", null, pw, null); &#125; mCommitted = true; if (mAddToBackStack) &#123; mIndex = mManager.allocBackStackIndex(this); &#125; else &#123; mIndex = -1; &#125; mManager.enqueueAction(this, allowStateLoss); return mIndex;&#125; 上面是commit的源代码，核心代码是倒数第二行，看到命令的执行最终还是有mManager控制，但是真的是这样吗？mManager到底是在哪个地方初始化的，还记得FragmentManagerImpl的beginTransaction方法吗？跳转到FragmentManagerImpl中，继续看enqueueAction12345678910111213141516171819202122232425/** * Adds an action to the queue of pending actions. * * @param action the action to add * @param allowStateLoss whether to allow loss of state information * @throws IllegalStateException if the activity has been destroyed */public void enqueueAction(Runnable action, boolean allowStateLoss) &#123; if (!allowStateLoss) &#123; checkStateLoss(); &#125; synchronized (this) &#123; if (mDestroyed || mHost == null) &#123; throw new IllegalStateException("Activity has been destroyed"); &#125; if (mPendingActions == null) &#123; mPendingActions = new ArrayList&lt;Runnable&gt;(); &#125; mPendingActions.add(action); if (mPendingActions.size() == 1) &#123; mHost.getHandler().removeCallbacks(mExecCommit); mHost.getHandler().post(mExecCommit); &#125; &#125;&#125; 从这个方法可以看出，真正执行执行Op命令的是mExecCommit这个线程，继续看mExecCommit线程。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Runnable mExecCommit = new Runnable() &#123; @Override public void run() &#123; execPendingActions(); &#125;&#125;;/*** Only call from main thread!*/public boolean execPendingActions() &#123; if (mExecutingActions) &#123; throw new IllegalStateException("Recursive entry to executePendingTransactions"); &#125; if (Looper.myLooper() != mHost.getHandler().getLooper()) &#123; throw new IllegalStateException("Must be called from main thread of process"); &#125; boolean didSomething = false; while (true) &#123; int numActions; synchronized (this) &#123; if (mPendingActions == null || mPendingActions.size() == 0) &#123; break; &#125; numActions = mPendingActions.size(); if (mTmpActions == null || mTmpActions.length &lt; numActions) &#123; mTmpActions = new Runnable[numActions]; &#125; mPendingActions.toArray(mTmpActions); mPendingActions.clear(); mHost.getHandler().removeCallbacks(mExecCommit); &#125; mExecutingActions = true; for (int i=0; i&lt;numActions; i++) &#123; mTmpActions[i].run(); mTmpActions[i] = null; &#125; mExecutingActions = false; didSomething = true; &#125; if (mHavePendingDeferredStart) &#123; boolean loadersRunning = false; for (int i=0; i&lt;mActive.size(); i++) &#123; Fragment f = mActive.get(i); if (f != null &amp;&amp; f.mLoaderManager != null) &#123; loadersRunning |= f.mLoaderManager.hasRunningLoaders(); &#125; &#125; if (!loadersRunning) &#123; mHavePendingDeferredStart = false; startPendingDeferredFragments(); &#125; &#125; return didSomething;&#125; 这是mExecCommit线程真正执行的方法，但是还是看不到任何关于Fragment被操作的痕迹，也看不到任何的Op命令，继续看execPendingActions方法，在这个方法中，有个代码片段吸引了我的注意12345678910111213141516171819202122232425262728293031for (int i=0; i&lt;numActions; i++) &#123; mTmpActions[i].run(); mTmpActions[i] = null; &#125;``在这我看到了run方法！！！而mTmpActions是mPendingActions的数组化，在`enqueueAction`中，mPendingActions是加载的是BackStackRecord!!!!!**而BackStackRecord是实现Runnable接口的！！**，现在一切都清楚了，真正执行Op命令的还是在BackStackRecord中。&lt;/br&gt;继续看BackStackRecord的run方法。```javawhile (op != null) &#123; ... switch (op.cmd) &#123; ... case OP_ADD: &#123; Fragment f = op.fragment; f.mNextAnim = enterAnim; mManager.addFragment(f, false); &#125; break; case OP_HIDE: &#123; Fragment f = op.fragment; f.mNextAnim = exitAnim; mManager.hideFragment(f, transition, transitionStyle); &#125; break; case OP_SHOW: &#123; Fragment f = op.fragment; f.mNextAnim = enterAnim; mManager.showFragment(f, transition, transitionStyle); &#125; break; ... &#125; op = op.next;&#125; 上面是run的部分代码，到这里我们终于看到了希望见到的Op命令！！在run方法中，while会遍历并执行Op链表中的所有命令，执行命令的过程最终还是通过mManager来执行，拿addFragment来示例，123456public void addFragment(Fragment fragment, boolean moveToStateNow) &#123; ... if (moveToStateNow) &#123; moveToState(fragment); &#125;&#125; 从上面的代码看到真正控制Fragment状态的是moveToState方法，多次跳转后最终跳转到12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) &#123; ... if (f.mState &lt; newState) &#123; ... switch (f.mState) &#123; case Fragment.INITIALIZING: ... f.onAttach(mHost.getContext()); ... case Fragment.CREATED: ... // onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) return 的View将在这里被指向 f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState); //onActivityCreated(savedInstanceState); 在这里被调用 f.performActivityCreated(f.mSavedFragmentState); // Fragment的View将在这被加载进Activity中 container.addView(f.mView); ... case Fragment.ACTIVITY_CREATED: case Fragment.STOPPED: ... // onStart() 在这里被调用 f.performStart(); ... case Fragment.STARTED: ... // onResume() 在这里被调用 f.performResume(); ... &#125; &#125;else if(f.mState &gt; newState)&#123; switch (f.mState) &#123; case Fragment.RESUMED: if (newState &lt; Fragment.RESUMED) &#123; if (DEBUG) Log.v(TAG, "movefrom RESUMED: " + f); // onPause()在这被调用 f.performPause(); f.mResumed = false; &#125; case Fragment.STARTED: if (newState &lt; Fragment.STARTED) &#123; if (DEBUG) Log.v(TAG, "movefrom STARTED: " + f); // onStop()在这被调用 f.performStop(); &#125; ... case Fragment.CREATED: if (newState &lt; Fragment.CREATED) &#123; if (f.mAnimatingAway != null) &#123; f.mStateAfterAnimating = newState; newState = Fragment.CREATED; &#125; else &#123; if (DEBUG) Log.v(TAG, "movefrom CREATED: " + f); if (!f.mRetaining) &#123; // onDestroy 在这被回调 f.performDestroy(); &#125; &#125; &#125; &#125;&#125; 由于篇幅所限，上面的只是代码片段，从moveToState方法中，我们见到了Fragment的整个生命周期！！！在第一个switch的case Fragment.CREATED:中Fragment 的 view 的被加载，不知道你是否还记得文章最开始的那个xml中id为content的FrameLayout，在这个case下，fragment的view正是被加载到这个Layout中！！！！！！这里有个有意思的地方，两个switch都是没有break语句的，当我们第一次add是，f.mState的默认状态为INITIALIZING，该状态下，fragemnt就要走完onAttach–onResume的所有流程，通过上面的代码，最终可以知道，fragment的全部生命周期都由mState这个字段决定。 到了现在getFragmentManager().beginTransaction().replace(R.id.content, details).commit();这句话我们算是完全清楚了它的工作流程。 总结在加载Fragament中，beginTransaction()创建了一个BackStackRecord对象，该对象实现了Runnable接口，replace方法将replace命令加载到BackStackRecord的Op链表中，当开发者调用commit方法时，commit方法将以事件的形式生成Op命令并将Op传递给FragmentManagerImpl，FragmentManagerImpl在Activity的handler中启动mExecCommit线程，mExecCommit线程执行BackStackRecord线程，在BackStackRecord的run方法里面，遍历所有Op链表，依次执行Op链表中所有的命令，run的switch根据Op命令，动态执行调用FragmentManagerImpl的replace、add、show等方法，在FragmentManagerImpl中的replace、add、show等方法最终都会调用moveToState方法，而整个Fragment的生命周期都在这个moveToState方法中。在这方法中，在create中，fragment最终将被加载找eginTransaction().replace(R.id.content, details)，replace第一个参数所指向的Layout中！！加载View完成后，moveToState将根据fragment的mState继续执行Fragment的生命周期。 到现在整个Fragment的生成加载，生命周期我们全部了解完成了，得出的最后一个结论是Fragment本质上是嵌入在Activity中一个ViewGroup的View，但是谷歌给这个View赋予了生命周期，看到Fragment后终于明白Square为什么要建议放弃Fragment了！！！虽然感觉Square公司有点偏激，但是作为一般开发者，在能用自定义View的情况下还是尽量不要用Fragment，因为Fragment实在太复杂了，一旦出现奇怪的问题，根本找不到哪个地方出的错，说多了都是泪！！！。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 仿当乐游戏详情页面(三)]]></title>
      <url>%2F2016%2F07%2F27%2FAndroid-%E4%BB%BF%E5%BD%93%E4%B9%90%E6%B8%B8%E6%88%8F%E8%AF%A6%E6%83%85%E9%A1%B5%E9%9D%A2-%E4%B8%89%2F</url>
      <content type="text"><![CDATA[在上两篇文章中，我们已经实现了基本的界面的布局和移动效果，但是mImgShotView、mContentView却不能响应事件，而事件的响应就需要我们手动进行事件分发！android 仿当乐游戏详情页面（一）android 仿当乐游戏详情页面（二）android 仿当乐游戏详情页面（三） 事件分发分析在前面第二篇中，我们是通过手势来实现布局的移动，为了让系统能响应手势，在onTouchEvent(MotionEvent event)方法里面，调用了mDetector.onTouchEvent(event);将系统的焦点传递给了手势，因此，当滑动mImgShotView这个ViewPager时，会出现焦点丢失，截图不能进行切换的问题。因此，解决这个问题最好的方法就是重写dispatchTouchEvent(MotionEvent ev)方法，对事件分发进行处理。在上一篇文章中，已经介绍了，在仿当乐的游戏详情页面中，mContentView有三种不同的状态： 顶部状态时，ToolBar和mContentView将获取到焦点。 中间状态时，ToolBar和mImgShotView将获取到焦点。 底部状态时，上一篇文章中已经介绍了，这个状态，mImgShotView的参数将发生改变，因此，事件焦点的分发便需要进行改变。 事件分发的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mRawY &lt;= mTopL) &#123; mCurrentState = STATE_TOP; &#125; else if (mTopL &lt; mRawY &amp;&amp; mRawY &lt;= mCenterL + (mBarH &gt;&gt; 1)) &#123; mCurrentState = STATE_CENTER; &#125; else if (mCenterL + (mBarH &gt;&gt; 1) &lt;= mRawY &amp;&amp; mRawY &lt; mBottomL + mBarH) &#123; mCurrentState = STATE_BOTTOM; &#125; else &#123; mCurrentState = STATE_OTHER; &#125; boolean isTop = mRawY == mTopL; // 处理横向滑动的事件 if (Math.abs(ev.getX() - mOldX) &gt;= 0 &amp;&amp; Math.abs(ev.getY() - mOldY) &lt; 300 &amp;&amp; isTop) &#123; mOldX = ev.getX(); return super.dispatchTouchEvent(ev); &#125; float t = Math.abs(ev.getY() - mOldY); //处于顶部时的事件过滤区域 if (isTop &amp;&amp; (ev.getY() &lt; mTopL || t &lt; 10)) &#123; return super.dispatchTouchEvent(ev); &#125; //处于中间时的事件过滤区域 if (mCurrentState == STATE_CENTER &amp;&amp; ev.getY() &lt; (mCenterL + mBarH) &amp;&amp; mRawY &gt;= mCenterL) &#123; return super.dispatchTouchEvent(ev); &#125; //处于底部时的事件过滤区域 if (mCurrentState == STATE_BOTTOM &amp;&amp; ev.getY() &lt; (mBottomL + mBarH) &amp;&amp; mRawY &gt;= mBottomL) &#123; return super.dispatchTouchEvent(ev); &#125; boolean isUp = ev.getY() - mOldY &lt; 0; if (isTop &amp;&amp; mCurrentState == STATE_TOP) &#123; mOldY = (int) ev.getY(); if (isScrollTop &amp;&amp; !isUp) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; return super.dispatchTouchEvent(ev); &#125; return onTouchEvent(ev); &#125; else &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; return super.dispatchTouchEvent(ev); &#125; return super.dispatchTouchEvent(ev); &#125; &#125; return onTouchEvent(ev);&#125; 以上便是事件分发的全部代码我们从最简单的地方开始分析代码，在上一篇文章中，定义了几个变量mTopL、mCenterL、mBottomL用来确定布局移动的基准位置，mRawY用来确定布局的当前的Y坐标。因此，便可以使用这几个变量来确认当前布局所处的状态：1231. mRawY &lt;= mTopL ==&gt; 布局处于顶部状态2. mTopL &lt; mRawY &amp;&amp; mRawY &lt;= mCenterL + (mBarH &gt;&gt; 1) ==&gt; 布局处于中间状态。3. mCenterL + (mBarH &gt;&gt; 1) &lt;= mRawY &amp;&amp; mRawY &lt; mBottomL + mBarH ==&gt; 布局处于底部状态 在2、3中，mBarH表示的是ToolBar的高度常量，+ mBarH，表示往下移动的偏移常量。 处理普通的事件过滤继续看代码，123456789101112131415float t = Math.abs(ev.getY() - mOldY);//处于顶部时的事件过滤区域if (isTop &amp;&amp; (ev.getY() &lt; mTopL || t &lt; 10)) &#123; return super.dispatchTouchEvent(ev);&#125;//处于中间时的事件过滤区域if (mCurrentState == STATE_CENTER &amp;&amp; ev.getY() &lt; (mCenterL + mBarH) &amp;&amp; mRawY &gt;= mCenterL) &#123; return super.dispatchTouchEvent(ev);&#125;//处于底部时的事件过滤区域if (mCurrentState == STATE_BOTTOM &amp;&amp; ev.getY() &lt; (mBottomL + mBarH) &amp;&amp; mRawY &gt;= mBottomL) &#123; return super.dispatchTouchEvent(ev);&#125; 第一个if语句，是用来处理顶部状态的事件过滤的，但是由于布局处于顶部状态时，mContentView需要获取事件，而mContentView是一个ViewPager，如果ViewPager加载的Fragment有滑动控件，将是一个很复杂的分发过程，而Fragment滑动控件的处理我们是必须考虑的。因此，第一个if语句里面，只处理mContentView的处于顶部状态时的点击事件，只要t小于10，就判断当前的事件为点击事件。而为了让焦点从手势交还给系统，只需要return super.dispatchTouchEvent(ev);便能将事件焦点拦截交还给系统。 第二个if语句就比较简单了，当处于中间状态时，只要事件的Y坐标小于mCenterL + mBarH坐标时，统统将事件焦点交还给系统, mRawY &gt;= mCenterL，有这个判断时，系统才能确定是中间状态时的事件过滤，不会导致晚上移动的情况下，莫名奇妙事件就交给了系统。 第三个if语句和第二个if语句差不多，mRawY &gt;= mBottomL这句代码同上所示，只有这个判断时，才能确认是底部事件的过滤，如果没有这句话，mContentView在中间状态时，就会处理，底部事件的过滤，将导致，mContentView处于中间状态时，将失去对手势的控制。 接下来便是处理mContentView的滑动控件的事件处理了！在当乐的游戏详情界面中，mContentView处于顶部时，里面的ListView或者ScrollView，只有滑动到最顶部时，再外下滑动，mContentView才能将焦点交还给系统。 处理Fragment 中滑动事件过滤12345678910111213141516boolean isUp = ev.getY() - mOldY &lt; 0;if (isTop &amp;&amp; mCurrentState == STATE_TOP) &#123; mOldY = (int) ev.getY(); if (isScrollTop &amp;&amp; !isUp) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; return super.dispatchTouchEvent(ev); &#125; return onTouchEvent(ev); &#125; else &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; return super.dispatchTouchEvent(ev); &#125; return super.dispatchTouchEvent(ev); &#125;&#125; 如上的代码所示，如果，当mContentView中的Fragment的滑动控件滑动到顶部，并且mContentView处于顶部，并且手势向上则将事件焦点交给手势，否则，交还给系统。这里需要注意以下两行代码:123if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; return super.dispatchTouchEvent(ev);&#125; 这两行代码是整个滑动事件分发的灵魂!!!，这两句代码是告诉系统，当焦点进行交换时，告诉当前掌控焦点的服务(系统、手势)交出焦点，重新进行分配！！如果没有这两句代码，焦点的切换将很有可能失败（就为了写出两行代码，工期延期了整整一个星期，说多了都是泪！！！！！！！）。 处理横向事件过滤1234if (Math.abs(ev.getX() - mOldX) &gt;= 0 &amp;&amp; Math.abs(ev.getY() - mOldY) &lt; 300 &amp;&amp; isTop) &#123; mOldX = ev.getX(); return super.dispatchTouchEvent(ev); &#125; 以上代码是实现mContentViewfragment的切换的，这代码很简单，只要是横向手势，并且X的偏差小于300就认为其是横向事件。 最终效果 写在最后来来回回一个多月，这个页面的blog算是写完了(整个功能实现也就7、8天，写着blog写了快两个月了，懒癌晚期伤不起)。现在的效果已经和当乐的差不多了，但是还是有点差别，比如，我这没有底部栏，比如，我这中间状态不能对mContentView进行切换，其实这些都很容易实现(其实我是懒癌晚期，不想写了..)最后还是说个思路吧： 底部导航栏那个，在布局里面写FrameLayout，然后编写自定义View，在主界面的代码里面，给mContentView设置addOnPageChangeListener事件监听，在滑动的过程中，FrameLayout动态添加你的自定义的导航栏View。（我在公司的APP里面采用的是这个思路） mContentView中间状态的切换，这个只需要在下面的语句中添加横向状态的添加横向手势移动的判断方法便可以了，需要注意下事件分发的范围123if (mCurrentState == STATE_CENTER &amp;&amp; ev.getY() &lt; (mCenterL + mBarH) &amp;&amp; mRawY &gt;= mCenterL) &#123; return super.dispatchTouchEvent(ev);&#125; 源代码其实上面说的全部都是废话，真正重要的还是源代码！！点击我获取源代码，最后跪求star和issues]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 仿当乐游戏详情页面(二)]]></title>
      <url>%2F2016%2F03%2F28%2FAndroid-%E4%BB%BF%E5%BD%93%E4%B9%90%E6%B8%B8%E6%88%8F%E8%AF%A6%E6%83%85%E9%A1%B5%E9%9D%A2-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[在上一篇文章里面，基本上算是实现了该效果的布局，有了布局，接下来就要对布局进行移动处理。android 仿当乐游戏详情页面（一）android 仿当乐游戏详情页面（二）android 仿当乐游戏详情页面（三） 对于移动的分析通过第一篇文章的分析，在所有控件里面，能移动的只有用于展示游戏简介和游戏相关数据的View，并且该View的移动有以下三种状态： 处于顶部的状态 中间状态 底部状态： 如上面几张图片所示，处于顶部状态，TabLayout 悬停在Toolbar的下面，而此时，用于介绍游戏简介的View被移出布局；处于中间状态时，Toolbar变为全透明状态，当位于底部时，用于展示游戏简介的View被固定在底部，其它的内容将被移出界面之外。 位置状态为了便于理解，首先像定义几个字段。123456789101112131. mImgShotView ==&gt; 由于展示游戏截图的View。2. mContentView ==&gt; 用于展示游戏信息的View。3. mGInfoView ==&gt; 用于展示游戏简介信息的View。3. mHeadView ==&gt; 包含mGInfoView和TabLayout的View。4. mHeadH ==&gt; mHeadView的高度。5. mBarH ==&gt; Toolbar 和 TabLayout的高度。6. mScreenH ==&gt; 当前可视屏幕高度。7. mStateBarH ==&gt; stateBar高度。8. mNBarH ==&gt; NavigationBar高度。9. mTopL ==&gt; 位于顶部状态时，mContentView 的 Y轴坐标基准位置。10. mCenterL ==&gt; 位于中间状态时，mContentView 的 Y轴坐标基准位置。11. mBottomL ==&gt; 位于底部状态时，mContentView 的 Y轴坐标基准位置。12. mRawY ==&gt; mContentView相对于当前可视界面的 Y 轴坐标。 顶部状态分析当处于顶部状态时，mGInfoView将被移出界面之外；在第一篇文章我们编写的布局里面，mContentView位于ToolBar下方，因此对于mContentView而言，它的基准坐标(y = 0)在Toolbar正下方；为了将mGInfoView移除界面之外，mContentView需要将Y坐标移动到-mHeadH + mBarH的位置。因此mTolL = -mHeadH + mBarH 中间状态分析对于中间状态，便简单多了，中间状态时，mContentView只需要将Y坐标往下移动到任一位置即可，此时，Toolbar处于完全透明状态。这里，我是将它往下距离它基准位置的150dp 的位置。因此mCenterL = Util.dp2px(150) 底部状态分析当mContentView处于底部状态，mGInfoView将被固定在屏幕底部，其它的内容将被除出界面之外。通过分析，很容易知道：mBottomL = mScreenH - mStateBarH - mNBarH - mHeadH + mBarH 代码实现现在，3种状态算是分析完成了，接下来便是代码的编写。在android 里面，对控件的移动操作，首先想到的是使用手势。同时，在手势移动的过程中，还需要对ToolBar进行透明度处理。mContentView的手势移动代码如下所示：1234567891011121314151617181920212223242526272829303132333435class SimpleGestureAction extends GestureDetector.SimpleOnGestureListener &#123; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; if (mRawY &lt;= mTopL &amp;&amp; distanceY &gt; 0) &#123; mRawY = mTopL; return true; &#125; if (mRawY &gt;= mBottomL &amp;&amp; distanceY &lt; 0) &#123; mRawY = mBottomL; return true; &#125; mRawY -= distanceY; if (mRawY &lt; mCenterL) &#123; a += distanceY &lt; 0 ? -0.03 : 0.03; if (a &lt; 0.0f) &#123; a = 0.0f; &#125; else if (a &gt; 1.0f) &#123; a = 1.0f; &#125; &#125; else &#123; a = 0.0f; &#125; if (mRawY &lt;= mTopL) &#123; mRawY = mTopL; a = 1.0f; mBarBg.setAlpha(a); mTemp.setAlpha(a); &#125; mContent.setTranslationY(mRawY); if (mRawY &gt;= mCenterL + mBarH) &#123; rotationBanner(true); &#125; return true; &#125;&#125; 以上是手势移动的全部代码，都是基本的控件移动操作。 mContentView 回归操作在上面的段落中，已经实现了对mContentView的移动操作。现在，我们可以随意对布局进行移动了；现在，如果对布局进行移动会发现，在对mContentView移动的过程中，如果放开手指，它并没有自动回弹到3个基准位置！这样的操作很不符合用户体验，并且也没有达到三个状态的要求。因此，我们需要定义几个阀值，当手指离开屏幕的时候，mContentView可以根据这几个阀值来判断它应该回归到具体哪个基准位置。阀值的定义如下：1231. 回归mTolL基准位置 ==&gt; mRawY &lt;= -mStateBarH2. 回归mCenterL基准位置 ==&gt; -mStateBarH &lt; mRawY &amp;&amp; mRawY &lt;= mCenterL + (mBarH &lt;&lt; 1)3. 回归mBottomL基准位置 ==&gt; mCenterL + (mBarH &lt;&lt; 1) &lt;= mRawY 具体的实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: if (mRawY &lt;= -mStateBarH) &#123; toTop(); &#125; else if ((-mStateBarH &lt; mRawY &amp;&amp; mRawY &lt;= mCenterL + (mBarH &lt;&lt; 1))) &#123; toCenter(); &#125; else if (mCenterL + (mBarH &lt;&lt; 1) &lt;= mRawY) &#123; toBottom(); &#125; return true; default: if (0 &lt;= a &amp;&amp; a &lt;= 1.0f) &#123; mBarBg.setAlpha(a); mTemp.setAlpha(a); &#125; mDetector.onTouchEvent(event); return super.onTouchEvent(event); &#125;&#125;/** 回到顶部 */private void toTop() &#123; AnimatorSet set = new AnimatorSet(); ObjectAnimator animator = ObjectAnimator.ofFloat(mContent, "translationY", mRawY, mTopL); ObjectAnimator alpha = ObjectAnimator.ofFloat(mBarBg, "alpha", a, 1.0f); ObjectAnimator alpha1 = ObjectAnimator.ofFloat(mTemp, "alpha", a, 1.0f); set.setDuration(500); set.play(animator).with(alpha).with(alpha1); set.start(); mRawY = mTopL; a = 1.0f; mBarBg.setAlpha(a); mTemp.setAlpha(a);&#125;/** 回到中间 */private void toCenter() &#123; ObjectAnimator animator = ObjectAnimator.ofFloat(mContent, "translationY", mRawY, mCenterL); animator.setDuration(500); animator.start(); mRawY = mCenterL; a = 0.0f; mBarBg.setAlpha(a); mTemp.setAlpha(a); mCurrentState = STATE_CENTER; rotationBanner(false);&#125;/** 回到底部 */private void toBottom() &#123; ObjectAnimator animator = ObjectAnimator.ofFloat(mContent, "translationY", mRawY, mBottomL); animator.setDuration(500); animator.start(); mRawY = mBottomL; a = 0.0f; mBarBg.setAlpha(a); mTemp.setAlpha(a); mCurrentState = STATE_BOTTOM; rotationBanner(true);&#125; 现在我们实现了布局的移动，同时也实现了mContentView的回归操作。这是我们现在的效果： 游戏截图旋转实现现在再看上面的效果，在对mContentView移动时，总感觉缺少点什么，再次回到当乐的游戏详情效果图，会看到，在移动的过程中，mImgShotView也会进行相应的操作，当mContentView从中间状态移动到底部状态时，mImgShotView会执行一个动画旋转操作。再看我们的效果，由于没有那个动画旋转效果，瞬间感觉low爆了。为了让效果更佳高大上，让我们来实现mImgShotView的旋转动画吧！！ mImgShotView旋转实现在当乐的效果中，mImgShotView的旋转看起来是ViewPager的旋转，实则是对ViewPager中Fragment的ImageView进行旋转，在旋转的过程中，ImageView在旋转90°同时会填充整个屏幕。在这里吐槽一下，看起来这种效果不难实现，但是等真正开发时会出现各种各样的坑，说多了都是泪，谁做谁知道 :( ！！！翻遍了这个stackoverflow都没有好的解决方案，最终研究出来使用属性动画是最简单实现并且性能是最好的！！ 为了便于理解，将定义一个字段 mBannerImg ==&gt; 实则是对ViewPager中Fragment中真正用于展示游戏截图的ImageView. 为了实现这种旋转放大的效果，在进行属性动画编写时，需要同时执行以下三个步骤：1231. 将mBannerImg 进行90°旋转。2. 将mBannerImg 移动到屏幕中间。3. 将mBannerImg 放大并填充整个屏幕。 具体的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243/** 旋转 */private void rotation(ImageView img, boolean useAnim) &#123; int w = Util.getWindowWidth(getActivity()), h = Util.getWindowHeight(getActivity()); int iw = img.getMeasuredWidth(), ih = img.getMeasuredHeight(); if (useAnim) &#123; ObjectAnimator move = ObjectAnimator.ofFloat(img, "translationY", 0, (h - ih) / 2f); move.setDuration(400); ObjectAnimator scaleX = ObjectAnimator.ofFloat(img, "scaleX", 1.0f, (float) h / iw); ObjectAnimator scaleY = ObjectAnimator.ofFloat(img, "scaleY", 1.0f, (float) w / ih); ObjectAnimator rotation = ObjectAnimator.ofFloat(img, "rotation", 0f, 90f); AnimatorSet set = new AnimatorSet(); set.play(scaleX).with(scaleY).with(rotation).with(move); set.setDuration(600); set.start(); &#125; else &#123; img.setTranslationY((h - ih) / 2f); img.setScaleX((float) h / iw); img.setScaleY((float) w / ih); img.setRotation(90f); &#125;&#125;/** 恢复 */private void resumeRotation(ImageView img, boolean useAnim) &#123; int w = Util.getWindowWidth(getActivity()), h = Util.getWindowHeight(getActivity()); int iw = img.getMeasuredWidth(), ih = img.getMeasuredHeight(); if (useAnim) &#123; ObjectAnimator move = ObjectAnimator.ofFloat(img, "translationY", (h - ih) / 2f, 0); move.setDuration(400); ObjectAnimator scaleX = ObjectAnimator.ofFloat(img, "scaleX", (float) h / iw, 1.0f); ObjectAnimator scaleY = ObjectAnimator.ofFloat(img, "scaleY", (float) w / ih, 1.0f); ObjectAnimator rotation = ObjectAnimator.ofFloat(img, "rotation", 90f, 0f); AnimatorSet set = new AnimatorSet(); set.play(scaleX).with(scaleY).with(rotation).with(move); set.setDuration(600); set.start(); &#125; else &#123; img.setTranslationY(0f); img.setScaleX(1.0f); img.setScaleY(1.0f); img.setRotation(0f); &#125;&#125; 以上便是旋转的核心代码。需要注意的是，mBannerImg在进行旋转并填充到整个界面的过程中，需要改变自己的高度参数，而在运行中改变View如果需要改变自己的参数，需要在View.post(new runable(){....})的线程里面执行；也就意味着，如果要让上面两个旋转方法生效，就需要将它们放在post线程里面，因此需要使用到Handler来执行UI的更新操作；我在这里是采用HandlerThread来实现这异步更新UI的操作。完整的旋转代码实现可以参考我的Demo例子。 mImgShotView旋转操作在上面的文章中，我们已经实现了mBannerImg的旋转，这个时候运行代码，移动mContentView时，将出现一个很有趣的现在mBannerImg旋转了，但只显示了一截，另一节被“吃掉了”。出现这个问题的原因是：在对图片进行旋转的过程中，属性动画已经改变了mBannerImg的高度参数。比如在mContentView处于底部状态时，mBannerImg的高度已经变为屏幕的高度，但是作为Fragment容器的mImgShotView的高度还是没有被改变；这就导致刚才所说的那个问题。知道了原因，解决就简单了，对mBannerImg进行操作前，只需要将mImgShotView的参数修改为与mBannerImg的参数一致便可，代码如下所示:1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 初始化游戏截图ViewPager */private void setupGameShotVp(final ViewPager viewPager) &#123; SimpleViewPagerAdapter adapter = new SimpleViewPagerAdapter(getSupportFragmentManager()); List&lt;BannerEntity&gt; data = getBannerData(); for (BannerEntity entity : data) &#123; adapter.addFrag(ScreenshotFragment.newInstance(entity), ""); &#125; viewPager.setAdapter(adapter); viewPager.setOffscreenPageLimit(data.size()); mIndicator.setViewPager(viewPager); viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; mShotVpPosition = position; &#125; @Override public void onPageSelected(int position) &#123;&#125; @Override public void onPageScrollStateChanged(int state) &#123;&#125; &#125;); //设置Banner图片高度 new Handler().post(new Runnable() &#123; @Override public void run() &#123; viewPager.post(new Runnable() &#123; @Override public void run() &#123; SimpleViewPagerAdapter adapter = (SimpleViewPagerAdapter) mImgVP.getAdapter(); int h = (int) getResources().getDimension(R.dimen.game_detail_head_img_vp_height); for (int i = 0, count = adapter.getCount(); i &lt; count; i++) &#123; ScreenshotFragment fragment = (ScreenshotFragment) adapter.getItem(i); if (fragment != null) &#123; fragment.setBannerHeight(h); &#125; &#125; &#125; &#125;); &#125; &#125;);&#125; 最终的效果 现在布局的移动和截图旋转算是完成了，接下来便是需要解决最困难的事件分发！！ Android 仿当乐游戏详情页(三)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 仿当乐游戏详情页面(一)]]></title>
      <url>%2F2016%2F03%2F21%2FAndroid-%E4%BB%BF%E5%BD%93%E4%B9%90%E6%B8%B8%E6%88%8F%E8%AF%A6%E6%83%85%E9%A1%B5%E9%9D%A2-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[前段时间接到了这样一个需求，要求实现一个和当乐游戏详情界面类似的界面；这是当乐游戏详情页面的效果！！ android 仿当乐游戏详情页面（一）android 仿当乐游戏详情页面（二）android 仿当乐游戏详情页面（三） 经过一段时间的摸索，爬过不少坑后，该界面总算是被实现出来了… 层次结构玩了几次当乐的界面后，发现其实当乐的界面并不难实现。首先从UI布局层次结构入手，该页面是由3种处在不同层次的View组合而成，然后通过中间层View的移动进而改变界面的显示状态，以达到动态的效果。通过观察，该页面分为3个不同的层次： 处于最底层的，不会动的View，该View用于显示游戏截图。 处于中间层的，会移动的View，该View用于展示游戏详情，该View由两个部分组成，一个是用来展示游戏简介的内容头部分View，也就是游戏图标所在的部分；另外一个是用来展示和游戏相关的内容信息的View，也就是当乐可以进行滑动的ViewPage。 处于最顶层的，toolbar 和底部工具栏 所处在的层次 层次结构如图所示： 绿色部分表是的处于底部的View，也就是用来展示游戏截图的部分。 黄色表示的是中间层，用来展示游戏详情及其和游戏相关的内容。 蓝色表和红色分别表示Toolbar 和 bottom Bar。 通过这层次结构的分析，便能很容易写出这种效果的界面。下面将开始实现布局代码。 界面布局代码界面的布局代码由几个部分组成 用来展示游戏简介的布局如上图所示，以下代码便是为了实现上图的效果。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/head" android:layout_width="match_parent" android:layout_height="@dimen/game_detail_head_height"&gt; &lt;View android:id="@+id/temp" android:layout_width="match_parent" android:layout_height="30dp" android:background="@color/transparent" /&gt; &lt;me.relex.circleindicator.CircleIndicator android:id="@+id/indicator" android:layout_width="match_parent" android:layout_height="@dimen/game_detail_head_indicator_height" android:gravity="center" /&gt; &lt;RelativeLayout android:id="@+id/head_content" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_below="@+id/temp" android:background="@color/white"&gt; &lt;TextView android:id="@+id/name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="130dp" android:layout_marginTop="8dp" android:text="游戏名" android:textColor="@color/text_black_color" android:textSize="@dimen/text_larger" /&gt; &lt;TextView android:id="@+id/detail" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignLeft="@+id/name" android:layout_below="@+id/name" android:text="角色扮演" android:textColor="@color/text_gray_color" android:textSize="@dimen/text_medium" /&gt; &lt;TextView android:id="@+id/feature" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignLeft="@+id/name" android:layout_below="@+id/detail" android:text="特性111111" android:textColor="@color/text_gray_color" android:textSize="@dimen/text_medium" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:layout_alignParentBottom="true" android:background="@color/line_color" /&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width="100dp" android:layout_height="50dp" android:layout_alignBottom="@+id/icon" android:layout_alignParentRight="true" android:visibility="gone" /&gt; &lt;ImageView android:id="@+id/icon" android:layout_width="100dp" android:layout_height="100dp" android:layout_marginLeft="16dp" android:layout_marginTop="10dp" android:src="@mipmap/default_icon" /&gt;&lt;/RelativeLayout&gt; 用于展示游戏详情的信息的布局如上图所示，以下代码便是要实现上面的效果，该部分由游戏简介的信息及其和游戏相关的信息(Viewpage)组合而成。12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/content" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_below="@+id/game_detail_bar" android:fitsSystemWindows="true" android:orientation="vertical"&gt; &lt;include layout="@layout/layout_game_detail_head" android:layout_width="match_parent" android:layout_height="@dimen/game_detail_head_height" /&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tab" style="@style/TabLayoutStyle" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@color/white" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="@color/line_color" /&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/content_vp" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 这个界面由两个部分组成，一个是我上面已经编写的用于展示游戏简介的View，在代码里面，通过了include 将其加载了进来；另外一个部分是用于展示和游戏相关的信息的界面(如，游戏评论、游戏评测、游戏礼包等等东西)，在当乐的界面里面，用户进行滑动实现不同界面的切换，由此，便可以猜的到，类似于游戏评论、游戏评测的界面，必定是一个Fragment，然后通过ViewPager作为容器，填充不同的Fragment；最后，当用户进行滑动时，便能切换不同的页面。 toolbar 布局由于滑动时需要动态设置Toolbar的透明度，所有需要自己手动创建一个简单的工具栏。以下代码便是Toolbar的具体布局.。1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/game_detail_bar" android:layout_width="match_parent" android:layout_height="@dimen/tool_bar_height" android:fitsSystemWindows="true"&gt; &lt;View android:id="@+id/bar_bg" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@color/colorPrimary" /&gt; &lt;TextView android:id="@+id/back" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_centerVertical="true" android:gravity="center" android:onClick="onClick" android:paddingLeft="-5dp" android:paddingRight="8dp" android:text="test" android:textColor="#fff" android:textSize="16sp" /&gt; &lt;ImageView android:id="@+id/download_manager" style="@style/BarImgStyle" android:layout_alignParentRight="true" android:onClick="onClick" android:scaleType="fitCenter" android:src="@mipmap/icon_download" /&gt;&lt;/RelativeLayout&gt; 主界面的代码实现接下来便是将上面的几个View组合起来，进而实现当乐游戏详情界面的基本布局。代码如下：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/img_vp" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;include layout="@layout/layout_content"/&gt; &lt;View android:id="@+id/state_bar_temp" android:layout_width="match_parent" android:layout_height="@dimen/state_bar_height" android:background="@color/colorPrimary"/&gt; &lt;include layout="@layout/layout_bar" android:layout_width="match_parent" android:layout_height="@dimen/tool_bar_height"/&gt;&lt;/RelativeLayout&gt; 为来实现层次效果的，需要使用到RelativeLayout进行布局，通过RelativeLayout的特性：当你不指定各个View的相对位置时，写在前面的View将被系统绘制在布局的最底层；和栈的有点相似。 所以在该布局里面，首先编写id为img_vpViewPager，该View便是用于展示游戏截图的View。 接下来便是编写用于展示游戏简介及其和游戏相关内容的View，&lt;include layout=&quot;@layout/layout_content&quot;/&gt; 代码便是将我们上面写的游戏展示信息的View加载进去了。 最后便是加载ToolBar&lt;include layout=&quot;@layout/layout_bar&quot;/&gt; 这是我们现在的效果当然，当这仅仅只是一个界面，并不能像当乐一样对界面进行移动。接下来，便需要开始编写布局移动的逻辑了。 Android 仿当乐游戏详情页(二)android 仿当乐游戏详情页面（三）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 仿Boss直聘跳转效果]]></title>
      <url>%2F2016%2F02%2F23%2FAndroid-%E4%BB%BFBoss%E7%9B%B4%E8%81%98%E8%B7%B3%E8%BD%AC%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[这段时间由于找工作的原因，下载了boss直聘，在ios最新版(4.1)上点击首页列表进行页面跳转的那个效果感觉很炫，但是android最新版本(4.2)上却没有对应的效果，不知道以前版本有没有，感觉很好奇，所以就有了本文… IOS版本boss直聘的效果 分析通过多次观察页面跳转动画，发现其实现过程也很简单:1、获取列表中item的位置。2、把根布局缩放0.9倍，同时跳出悬浮框，添加一个View(暂且称它为tempView)，设置tempView的高度和宽度为列表的item的高度和宽度。3、对tempView进行缩放，缩放倍数为tempView距离屏幕顶部，距离屏幕底部中的最大值处于tempView高度: Math.max(tempView.locationX, Math.abs(tempView.locationX - ScreenHeight)) / tempView.height。4、在安卓上，即使设置1Intent.FLAG_ACTIVITY_NO_ANIMATION 在部分机型上也无法禁止动画，如果按照正常的步骤，关闭悬浮框再进行页面跳转，就达不到boss直聘上的跳转效果，所以就需要当tempView展开到最大时，马上进行页面跳转。5、启动加载等待动画，延时1秒后，启动alpha动画，将tempView透明度设置为0，关闭悬浮框。 悬浮框代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public class BossTransferView extends LinearLayout &#123; private static final String TAG = "ExpansionTemp"; private View mHandleView; private WindowManager mWm; private ImageView mImg; private View mTemp; private ImageView mPb; private int[] mLocation = new int[2]; private View mRootView; public BossTransferView(Context context, View rootView, View handleView, WindowManager wm) &#123; super(context, null); mHandleView = handleView; mRootView = rootView; mWm = wm; init(); &#125; public BossTransferView(Context context, AttributeSet attrs) &#123; super(context, attrs, 0); &#125; public BossTransferView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; private void init() &#123; LayoutInflater.from(getContext()).inflate(R.layout.layout_boss_transfer, this); mImg = (ImageView) findViewById(R.id.img); mTemp = findViewById(R.id.line);// mPb = (ProgressBar) findViewById(R.id.progress); mPb = (ImageView) findViewById(R.id.progress); mHandleView.getLocationInWindow(mLocation); int sbh = Util.getStatusBarHeight(getContext()); mImg.setTranslationY(mLocation[1] - sbh); mTemp.setTranslationY(mLocation[1] + mImg.getMeasuredHeight() / 2 + sbh); mPb.setVisibility(GONE); Bitmap bm = getViewImg(mHandleView); if (bm != null) &#123; mImg.setImageBitmap(getViewImg(mHandleView)); &#125; AnimationDrawable ad = new AnimationDrawable(); ad.addFrame(getDrawable(R.mipmap.icon_refresh_left), 200); ad.addFrame(getDrawable(R.mipmap.icon_refresh_center), 200); ad.addFrame(getDrawable(R.mipmap.icon_refresh_right), 200); mPb.setImageDrawable(ad); ad.setOneShot(false); ad.start(); &#125; private Drawable getDrawable(@DrawableRes int drawable)&#123; return getContext().getResources().getDrawable(drawable); &#125; public void show() &#123; handleRootView(); setBackgroundColor(Color.parseColor("#7f000000")); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; mTemp.setVisibility(View.VISIBLE); expansion(); &#125; &#125;, 500); &#125; private void handleRootView() &#123; ObjectAnimator setScaleY = ObjectAnimator.ofFloat(mRootView, "scaleY", 1f, 0.95f); ObjectAnimator setScaleX = ObjectAnimator.ofFloat(mRootView, "scaleX", 1f, 0.95f); AnimatorSet set = new AnimatorSet(); set.play(setScaleX).with(setScaleY); set.setDuration(500); set.start(); &#125; public Bitmap getViewImg(View view) &#123; view.setDrawingCacheEnabled(true); view.buildDrawingCache(); int width = Util.getScreenParams(getContext())[0]; Bitmap bmp = view.getDrawingCache(); if (bmp == null) &#123; return null; &#125; Bitmap bp; bp = Bitmap.createBitmap(bmp, 0, 0, width, bmp.getHeight()); view.destroyDrawingCache(); return bp; &#125; /** * 扩展到整个屏幕 */ private void expansion() &#123; int wh = Util.getScreenParams(getContext())[1]; int sbh = Util.getStatusBarHeight(getContext()); int h = Math.max(mLocation[1], Math.abs(mLocation[1] - wh)); ObjectAnimator animator = ObjectAnimator.ofFloat(mTemp, "scaleY", 1f, h + sbh); animator.setDuration(500); animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); mImg.setVisibility(View.GONE); Intent intent = new Intent(getContext(), BossDetailActivity.class); getContext().startActivity(intent); mRootView.setScaleY(1f); mRootView.setScaleX(1f); mPb.setVisibility(VISIBLE); setBackgroundColor(Color.TRANSPARENT); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; fade(); &#125; &#125;, 1000); &#125; &#125;); animator.start(); &#125; /** * 淡出 */ private void fade() &#123; mPb.setVisibility(GONE); ObjectAnimator animator = ObjectAnimator.ofFloat(mTemp, "alpha", 1f, 0f); animator.setDuration(800); animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); mTemp.setVisibility(GONE);// mTemp.setScaleY(1f); mPb.setVisibility(GONE); mWm.removeView(BossTransferView.this); &#125; &#125;); animator.start(); &#125;&#125; 由于涉及到两个Activity间的跳转，所以悬浮框就需要一直处于最显示层的最顶层，并且该悬浮框需要全局通用。在andorid里面可以使用WindowManager配合自定义View来实现悬浮框功能，上面便是悬浮框的自定义View。上面的核心参数是：mLocation，该数组是item在屏幕上的位置，通过1view.getLocationInWindow(mLocation); 方法，便可以轻松得到一个View在屏幕上的位置，不同于boss直聘上tempView的空白展开的是，我这里使用了item的图像缓存代替了boss直聘上tempView的位置，而填充整个页面任务是由tempView处于中间位置的一个1dp高度的view进行展开，进而覆盖整个屏幕。当展开到最大屏幕时，进行页面跳转，并将加载动画显示出来，将动画加载一秒，进行淡出操作，最终，将自定义的悬浮框View从WindowManager移除 跳转类由于一个工程项目中不可能只有一个列表，因此需要创建一个跳转帮助类，来实现跳转1234567891011121314151617181920212223242526272829public class TurnHelp &#123; /** * 带动画跳转详情页面 */ public static void turn(Context context, View rootView, View itemView) &#123; WindowManager wm = (WindowManager) context.getApplicationContext().getSystemService(Context.WINDOW_SERVICE); WindowManager.LayoutParams wmParams; BossTransferView temp = new BossTransferView(context, rootView, itemView, wm); wmParams = new WindowManager.LayoutParams();//感谢5楼的小伙伴提出的解决小米等机型默认禁止弹出悬浮框的方案，直接把type，改为toast就可以了 wmParams.type = WindowManager.LayoutParams.TYPE_TOAST; // 系统提示类型,重要 wmParams.format = 1; wmParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; // 不能抢占聚焦点 wmParams.flags = wmParams.flags | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH; wmParams.flags = wmParams.flags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS; // 排版不受限制 wmParams.flags = wmParams.flags | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL; // 排版不受限制 wmParams.alpha = 1.0f; wmParams.gravity = Gravity.LEFT | Gravity.TOP; //调整悬浮窗口至左上角 //以屏幕左上角为原点，设置x、y初始值 wmParams.x = 0; wmParams.y = 0; //设置悬浮窗口长宽数据 wmParams.width = WindowManager.LayoutParams.MATCH_PARENT; wmParams.height = WindowManager.LayoutParams.MATCH_PARENT; //显示myFloatView图像 wm.addView(temp, wmParams); temp.show(); &#125;&#125; 上面没啥好说的，就是WindowManager添加View的基本操作 启动代码12345678910111213141516171819202122232425262728293031323334353637383940private View mItemView;mList.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; mItemView = view; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M &amp;&amp; checkSelfPermission(Settings.ACTION_MANAGE_OVERLAY_PERMISSION) == PackageManager.PERMISSION_GRANTED) &#123; requestAlertWindowPermission(); &#125; else &#123; TurnHelp.turn(MainActivity.this, findViewById(android.R.id.content), view); &#125; &#125; &#125;);/*** 6.0申请悬浮框权限*/private void requestAlertWindowPermission() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION); intent.setData(Uri.parse("package:" + getPackageName())); startActivityForResult(intent, 1); &#125;&#125;/*** 6.0权限 回调*/@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == 1 &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if (Settings.canDrawOverlays(this)) &#123; TurnHelp.turn(MainActivity.this, findViewById(android.R.id.content), mItemView); &#125; else &#123; Toast.makeText(this, "申请悬浮框权限失败", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 最终效果 DEMO点我]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 最简单的导航栏实现]]></title>
      <url>%2F2015%2F12%2F17%2FAndroid-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[在开发中，我们经常碰到这样的控件，用来切换不同的Fragment 这种控件的实现的效果有多种多样，一般来说我们都是使用一个LinearLayout嵌套几个Button来实现，然后通过for循环来实现单一的选择。 虽然代码量不多，但对于我们这样有追求的人来说，是不会屑于使用方式了。因为android上已经有了个RadioGroup了，为毛还要写个for循环来控制单一的选择状态呢。 废话少说，直接上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior" tools:context="com.example.yuyu.navigationbardemo.MainActivity" tools:showIn="@layout/activity_main"&gt; &lt;FrameLayout android:id="@+id/content" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_above="@+id/navigation" /&gt; &lt;RadioGroup android:id="@+id/navigation" android:layout_width="match_parent" android:layout_height="50dp" android:layout_alignParentBottom="true" android:background="@android:color/white" android:orientation="horizontal"&gt; &lt;!--android:drawableTop="@mipmap/ic_launcher"--&gt; &lt;!--top的图片直接设置选择器的了，选择器状态state--&gt; &lt;RadioButton style="@style/MainRadioButtonStyle" android:tag="0" android:text="红色" /&gt; &lt;RadioButton style="@style/MainRadioButtonStyle" android:tag="1" android:text="蓝色" /&gt; &lt;RadioButton style="@style/MainRadioButtonStyle" android:tag="2" android:text="绿色" /&gt; &lt;RadioButton style="@style/MainRadioButtonStyle" android:tag="3" android:text="黄色" /&gt; &lt;/RadioGroup&gt;&lt;/RelativeLayout&gt; 没啥好说的，这就一个简单的布局代码，要注意的是，在RadioButton里面我使用了自定义的风格。 这是RadioButton自定义风格，也没啥好说的 123456789101112&lt;style name=&quot;MainRadioButtonStyle&quot;&gt; &lt;item name=&quot;android:layout_marginTop&quot;&gt;8dp&lt;/item&gt; &lt;item name=&quot;android:drawablePadding&quot;&gt;2dp&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;match_parent&lt;/item&gt; &lt;item name=&quot;android:layout_width&quot;&gt;wrap_content&lt;/item&gt; &lt;item name=&quot;android:layout_marginBottom&quot;&gt;5dp&lt;/item&gt; &lt;item name=&quot;android:textSize&quot;&gt;12sp&lt;/item&gt; &lt;item name=&quot;android:layout_weight&quot;&gt;1&lt;/item&gt; &lt;item name=&quot;android:button&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:gravity&quot;&gt;center&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@drawable/selector_navigation_text_bg&lt;/item&gt; &lt;/style&gt; 同时为了能让被选择的字体变色，我们需要一个字体选择器和一个图标的选择器，选择器依然没什么好说的..唯一需要注意的是：两个选择器的状态需要一致 字体颜色选择器：1234&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:color="@color/colorPrimary" android:state_checked="true" /&gt; &lt;item android:color="@android:color/black" android:state_checked="false" /&gt;&lt;/selector&gt; 图标选择器：1234&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/icon_selected" android:state_checked="true" /&gt; &lt;item android:drawable="@mipmap/icon_un_selected" android:state_checked="false" /&gt;&lt;/selector&gt; 布局文件什么的已经上完，是时候来搞java代码了，不废话，还是直接上java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class MainActivity extends AppCompatActivity implements RadioGroup.OnCheckedChangeListener &#123; private String TAG = "MainActivity"; private RadioGroup mNavigationBar; private FragmentManager mFm; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); &#125; private void init() &#123; mFm = getSupportFragmentManager(); mNavigationBar = (RadioGroup) findViewById(R.id.navigation); //设置图标 int size = (int) getResources().getDimension(R.dimen.navigation_top_icon_size); for (int i = 0, count = mNavigationBar.getChildCount(); i &lt; count; i++) &#123; RadioButton rb = (RadioButton) mNavigationBar.getChildAt(i); Drawable topIcon = getResources().getDrawable(R.drawable.selector_navigation_bg); topIcon.setBounds(0, 0, size, size); rb.setCompoundDrawables(null, topIcon, null, null); rb.setId(i); &#125; mNavigationBar.setOnCheckedChangeListener(this); ((RadioButton) mNavigationBar.getChildAt(0)).setChecked(true); &#125; //进行Fragment切换 private void chooseFragment(String tag) &#123; int color = Color.RED; switch (tag) &#123; case "0": color = Color.RED; break; case "1": color = Color.BLUE; break; case "2": color = Color.GREEN; break; case "3": color = Color.YELLOW; break; &#125; Fragment fragment = DummyFragment.newInstance(color); FragmentTransaction ft = mFm.beginTransaction(); ft.replace(R.id.content, fragment); ft.commit(); &#125; @Override public void onCheckedChanged(RadioGroup group, int checkedId) &#123; RadioButton rb = (RadioButton) group.getChildAt(checkedId); if (rb.isChecked()) &#123; chooseFragment(String.valueOf(rb.getTag())); &#125; &#125; @SuppressLint("ValidFragment") public static class DummyFragment extends Fragment &#123; int color; public static DummyFragment newInstance(@ColorInt int color) &#123; return new DummyFragment(color); &#125; private DummyFragment() &#123; &#125; private DummyFragment(int color) &#123; this.color = color; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.test_game_detail_fragment, container, false); view.setBackgroundColor(color); return view; &#125; &#125;&#125; 简单吧，这就是全部的控制代码了，虽然有几十行，但是核心的代码也就那么几行，核心方法就是onCheckedChanged回调函数，在最开始初始化控件的时候，我们按照排列顺序依次给没一个RadioButton设置了递增的id，所以在RadioGroup被选中时，便可以直接获取到被点中的子控件。 这里还有个坑需要注意！！！那便是设置图标的时候，不能直接把下面这代码提到循环外1Drawable topIcon = getResources().getDrawable(R.drawable.selector_navigation_bg); 如果提到循环外，那他便是一个局部变量，会同时被所有RadioButton共用，到时候进行状态选择时，图标的状态将完全混乱！！ 好了，最后是效果图： 最后的最后便是源代码快，点击我]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Logger 日志框架实现]]></title>
      <url>%2F2015%2F11%2F29%2FAndroid-Logger-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[可以这样说，Log日志是除了debug外我们调试程序的全部了，但是在实际的开发中，系统原生的Log功能并不强大，它只能打印简单的字符串，如果碰到JSON，MAP一类的特殊字符串它的打印效果将极其糟糕。 机缘巧合下，我有幸见在github上见到了一个功能很强大的LOG日志库Logger，它功能强大，当你使用它打印LOG日志时，它不仅能把普通的字符串打印出来，甚至能定位你打印的位置。并且它能直接将JSON字符串格式化并打印出来，省下了我们手动格式化JSON字符串的时间。 下面是它的打印效果图 简单Logger日志实现好了，看完Logger的功能介绍和效果图，想必你也很心动，也想要搞这样一个Logger库。现在如果你想拥有这样一个日志系统，那么有两个简单的方法来供你选择： 一、Clone 点击我，然后关闭此窗口… 二、继续往下看。 非常感谢你留下来继续看我的废话，现在让我们一起研究Logger的主要功能吧！ JSON格式化部实现当我第一次使用Logger JSON格式化的功能时，我心情是悲伤的，因为它让我抛弃了陪伴我多年的JSON格式化网页。本着无比悲痛的心情，有生以来我第一次极其认真的查看了开源项目的代码。后来，看完代码后的我，心情是崩溃的，原本以为JOSN格式化这么高达上的功能一定是很复杂的代码实现，后来发现尼玛就一行代码就能搞定，这是什么鬼啊，说好的复杂代码呢？？12345678910111213141516171819202122232425262728/** * 打印JSON * * @param jsonStr */ public static void j(String jsonStr) &#123; if (isDebug) &#123; String message; try &#123; if (jsonStr.startsWith("&#123;")) &#123; JSONObject jsonObject = new JSONObject(jsonStr); message = jsonObject.toString(JSON_INDENT); //这个是核心方法 &#125; else if (jsonStr.startsWith("[")) &#123; JSONArray jsonArray = new JSONArray(jsonStr); message = jsonArray.toString(JSON_INDENT); &#125; else &#123; message = jsonStr; &#125; &#125; catch (JSONException e) &#123; message = jsonStr; &#125; message = LINE_SEPARATOR + message; String[] lines = message.split(LINE_SEPARATOR); StringBuilder sb = new StringBuilder(); printLog(D, lines);//请不要关注这行，这是控制台输出的Log方法 &#125; &#125; 以上就是JSON格式化的方法，想必你和我当初一样充满了错愕，我们每天都在用toString()、toString()…然后竟然不知道还有个toString(int xxxx)的重载方法！！！！ 是的，高大上的JSON格式化功能不需要你998行代码，也不需要你99行代码，没错，你没看错，它就只需要你一行toString(int xxxx)，并且附带赠送你xxxx个缩进空格！！ 代码定位的实现当年，我还是个孩子的时候我就知道我很无知，后来当我看了Logger的Json格式化代码的实现后，我已经对它不屑一顾。后来当我看了代码定位的功能后，我觉得我还是太年轻了…123456789101112131415161718192021222324252627282930/** * 代码定位 * * @param type */ private static void printLocation(char type, String... msg) &#123; StackTraceElement[] stack = Thread.currentThread().getStackTrace(); int i = 0; //获取代码所运行的位置 for (StackTraceElement e : stack) &#123; String name = e.getClassName(); if (!name.equals(L.class.getName())) &#123; i++; &#125; else &#123; break; &#125; &#125; //进行方法位置偏移 i += 3; //当我能准确获取到I时，本部分已经完结，以下代码都是废话，请不要关注 String className = stack[i].getFileName(); String methodName = stack[i].getMethodName(); int lineNumber = stack[i].getLineNumber(); StringBuilder sb = new StringBuilder(); printHunk(type, HORIZONTAL_DOUBLE_LINE + " Location:"); sb.append(HORIZONTAL_DOUBLE_LINE) .append(" (").append(className).append(":").append(lineNumber).append(")# ").append(methodName); printHunk(type, sb.toString()); printHunk(type, msg == null || msg.length == 0 ? BOTTOM_BORDER : MIDDLE_BORDER); &#125; 注：上面并不是纯粹的Logger源码，那是我根据Logger的思路自己写的代码定位功能，事实上Logger源代码那部分写得很优秀，但是你也懂的，优秀也就意味着代码不好看懂… 好吧，我承认，我当初就是因为看这部分看得心烦，感觉很不爽，然后一怒之下，根据它的思路重新来写的。。。 好吧，现在来所说代码定位的原理。如下图所示：我想，上面的图你一定很熟悉，没错，那就是我们经常用的debug 然后watch某个元素时候的界面。在上面的图片中，我们看到了一堆数组，其中圈红色的部分是不是感觉有点特殊，因为包名并不是系统的包名，那些都是我们自己的类，自己的方法的元素。 现在，我想聪明的你已经懂了，代码定位的原理是通过Thread.currentThread().getStackTrace()方法获取到所有的运行元素，并根据获取到的数组，进行一定的偏移来准确捕获Looger( )被调用的真正位置。 根据JVM的运行原理，每当JVM执行一个方法时，它都会把该方法压到一个方法栈里面，根据栈的后入先出原则，我们可以知道，Logger( )被调用的位置一定是方法栈里面最先被压入的函数的位置。也就是红圈里面的最后一个元素。也就是我为什么要 i += 3的原因； 附上我自己写的类L（Logger）的调用流程： 我们终于获取到了代码所在行的确切位置了，要在控制台上实现代码定位也就简单多了。 根据获取到的StackTraceElement元素，我们能通过api接口获取到运行类的类名及其该方法所被调用的位置，然后按照下面的格式进行封装，便能实现控制台代码的定位。代码定位格式：（类名：代码行）只要按照上面的规则进行组合类名和行，再通过系统提供的Log进行输出，便能通过控制台直接跳转到所在的代码行。 打印Map这个没啥好说的…12345678910111213141516171819/** * 打印MAp */ public static void m(Map map) &#123; Set set = map.entrySet(); if (set.size() &lt; 1) &#123; printLog(D, &quot;[]&quot;); return; &#125; int i = 0; String[] s = new String[set.size()]; for (Object aSet : set) &#123; Map.Entry entry = (Map.Entry) aSet; s[i] = entry.getKey() + &quot; = &quot; + entry.getValue() + &quot;,\n&quot;; i++; &#125; printLog(V, s); &#125; 最终效果 最重要的还是放在最后面我是伟大的DEMO]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 仿微信侧滑关闭页面效果]]></title>
      <url>%2F2015%2F10%2F29%2FAndroid-%E4%BB%BF%E5%BE%AE%E4%BF%A1%E4%BE%A7%E6%BB%91%E5%85%B3%E9%97%AD%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[最近手机升级了5.0系统后，突然间发现微信竟然有IOS一样的侧滑关闭当前页面的效果，就想把这种效果也加进自己的项目里面。本着不重复造轮子的原则，就在网上百度了很久，发现大多数人都是采用自定义View来实现，但是对于我这种已经基本完成的项目来说，如果全部的Activity再重新使用自定义的View无疑是一种可怕的噩梦。因此，我这里实现了另外一种不需要自定义View也能实现的方法，其子类只要继承于它，便能拥有其侧滑滑动的功能。随便说一句，此方法仅对5.0以上的手机有效（反正微信也是5.0上才能用），5.0以下的请无视！！！ 以上都是废话~~~~ 原理在每个Activity里面都有一个底层的View，也就是所谓的rootView，当我们加载一个xml布局时，系统就会自动给你生成这个rootView，由于它是一个View，那么也就意味着你可以通过一定的代码随意移动这个根布局。如下代码所示，只要简单的几行代码便能实现布局的移动。12345678910111213141516171819202122232425262728293031323334353637383940414243public class SlideActivity extends AppCompatActivity &#123; View mRootView; private GestureDetector mDetector; private int mWindowWidth; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo); mRootView = getWindow().getDecorView(); mRootView.setBackgroundColor(Color.BLUE); mDetector = new GestureDetector(this, new GestureListener()); mWindowWidth = getWindow().getWindowManager().getDefaultDisplay().getWidth(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; return mDetector.onTouchEvent(event); &#125; /** * 手势监听 */ private class GestureListener extends GestureDetector.SimpleOnGestureListener &#123; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; if (e1 != null) &#123; handlerCurrentActivityScroll(e2); &#125; return super.onScroll(e1, e2, distanceX, distanceY); &#125; /** * 处理当前页面滑动 */ private void handlerCurrentActivityScroll(MotionEvent e2) &#123; mRootView.setTranslationX(e2.getX()); if (e2.getX() &gt; mWindowWidth - 20) &#123; finish(); &#125; &#125; &#125;&#125; 这是我们的效果 Activity联动尼玛，这差距还是很大的，最明显的地方是，我们移动 的时候，上一层Activity竟然没有跟着联动。解决这个问题的方法也简单，如图所示，每当启动一个Activity时，系统都会把Activity放到一个栈里面，由于栈的工作原理可知，APP里面的Activity是一层覆盖一层的，就如上图所示。为此，每当启动一个Activity时，就可以把当前的Actiivty存储到一个List里面，这样，我们就可以在当前的Activity里面取出上一个Activity进行操作。因此，在进入一个新的Activity的时候，在其onCreate方法里面把当前的Activity加载到列表里，当退出时，在finish的重载方法里面，将当前Activity从列表里面移除。注意！！！在滑动的时候必须需要考虑到Activity里面有可能会有类似于ListView一类的滑动控件，因此，我们必须对事件进行分发控制。代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * Created by yuyu on 2015/10/29. */public class TestActivity extends AppCompatActivity &#123; View mRootView; private GestureDetector mGestureDetector; private static List&lt;TestActivity&gt; mActivitys = new ArrayList&lt;&gt;(); /** * 移动距离 */ private float mWindowWidth; private TestActivity mBeforeActivity; /** * 上一个Activity偏移量 */ private float mOffsetX; /** * 上一个页面移出的位置 */ private float mOutsideWidth; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo); /** * 把当前Activity加到列表里面 */ mActivitys.add(this); initScrollBack(); &#125; /** * 初始化左滑退出功能 */ private void initScrollBack() &#123; mWindowWidth = getWindowManager().getDefaultDisplay().getWidth(); mOutsideWidth = -mWindowWidth / 4; mOffsetX = mOutsideWidth; mGestureDetector = new GestureDetector(this, new GestureListener()); mRootView = getWindow().getDecorView(); mRootView.setBackgroundColor(Color.BLUE); &#125; /** * 控制分发事件，在这里控制能能触发拖动的范围 */ @Override public boolean dispatchTouchEvent(@NonNull MotionEvent ev) &#123; if (ev.getX() &lt; mWindowWidth / 10) &#123; if (mActivitys.size() &gt; 1) &#123; mBeforeActivity = mActivitys.get(mActivitys.size() - 2); beforeActivityTranslationX(mOutsideWidth); &#125; return onTouchEvent(ev); &#125; return super.dispatchTouchEvent(ev); &#125; @Override public void finish() &#123; mActivitys.remove(this); if (mOffsetX &lt; 0.0001 || mOffsetX &gt; 0.0001) &#123; beforeActivityTranslationX(0); &#125; super.finish(); &#125; public void onClick(View view) &#123; Intent intent = new Intent(this, Activity5.class); startActivity(intent); &#125; public View getRootView() &#123; return mRootView; &#125; /** * 控制上一个Activity移动 */ private void beforeActivityTranslationX(float translationX) &#123; if (mBeforeActivity != null) &#123; mBeforeActivity.getRootView().setTranslationX(translationX); &#125; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; return mGestureDetector.onTouchEvent(event); &#125; /** * 手势监听 */ private class GestureListener extends GestureDetector.SimpleOnGestureListener &#123; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; if (e1 != null) &#123; handlerCurrentActivityScroll(e2); handleBeforeActivityScroll(e2, distanceX); &#125; return super.onScroll(e1, e2, distanceX, distanceY); &#125; /** * 处理当前页面滑动 */ private void handlerCurrentActivityScroll(MotionEvent e2) &#123; mRootView.setTranslationX(e2.getX()); if (e2.getX() &gt; mWindowWidth - 20) &#123; finish(); &#125; &#125; /** * 处理上一个页面滑动 */ private void handleBeforeActivityScroll(MotionEvent e2, float distanceX) &#123; if (mBeforeActivity != null) &#123; mOffsetX = distanceX &lt; 0 ? mOffsetX + Math.abs(distanceX) / 4 : mOffsetX - Math.abs(distanceX) / 4; if (mOffsetX &gt; 0.0001) &#123; mOffsetX = 0f; &#125; mBeforeActivity.getRootView().setTranslationX(mOffsetX); &#125; &#125; &#125;&#125; 这是联动后的效果图现在算是有点效果了，但是和微信的差距还是很大，接下来我们便需要开始处理自动滑动了 自动滑动这个就不需要多说了，这个主要就是利用属性动画进行移动以下是完整的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174public class SlideActivity extends AppCompatActivity &#123; private static final String TAG = "SlideActivity"; private static List&lt;SlideActivity&gt; mActivitys = new ArrayList&lt;&gt;(); /** * 手势监听 */ private GestureDetector mGestureDetector; private View mRootView; private boolean isScroll = false; /** * 移动距离 */ private float mWindowWidth; private SlideActivity mBeforeActivity; /** * 上一个Activity偏移量 */ private float mOffsetX; /** * 上一个页面移出的位置 */ private float mOutsideWidth; private boolean canScrollBack = true; private boolean canScroll = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); getWindow().setEnterTransition(new Slide(Gravity.RIGHT)); super.onCreate(savedInstanceState); /** * 把当前Activity加到列表里面 */ mActivitys.add(this); initScrollBack(); &#125; @Override public void startActivity(Intent intent) &#123; startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this).toBundle()); &#125; /** * 初始化左滑退出功能 */ private void initScrollBack() &#123; mWindowWidth = getWindowManager().getDefaultDisplay().getWidth(); mOutsideWidth = -mWindowWidth / 4; mOffsetX = mOutsideWidth; mGestureDetector = new GestureDetector(this, new GestureListener()); mRootView = getWindow().getDecorView(); &#125; /** * 控制上一个Activity移动 */ private void beforeActivityTranslationX(float translationX) &#123; if (mBeforeActivity != null) &#123; mBeforeActivity.getRootView().setTranslationX(translationX); &#125; &#125; /** * 设置是否能滑动 * * @param canScrollBack true 可以滑动 */ protected void setCanScrollBack(boolean canScrollBack) &#123; this.canScrollBack = canScrollBack; &#125; public View getRootView() &#123; return mRootView; &#125; @Override public void finish() &#123; mActivitys.remove(this); if (mOffsetX &lt; 0.0001 || mOffsetX &gt; 0.0001) &#123; beforeActivityTranslationX(0); &#125; super.finish(); &#125; /** * 控制分发事件 */ @Override public boolean dispatchTouchEvent(@NonNull MotionEvent ev) &#123; if (canScrollBack &amp;&amp; ev.getX() &lt; mWindowWidth / 10) &#123; if (mActivitys.size() &gt; 1) &#123; mBeforeActivity = mActivitys.get(mActivitys.size() - 2); beforeActivityTranslationX(mOutsideWidth); &#125; canScroll = true; return onTouchEvent(ev); &#125; return super.dispatchTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (canScrollBack &amp;&amp; canScroll) &#123; if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; isScroll) &#123; isScroll = false; canScroll = false; //退出当前Activity if (event.getX() &gt; mWindowWidth / 2) &#123; if (mBeforeActivity != null) &#123; ObjectAnimator.ofFloat(mBeforeActivity.getRootView(), "translationX", mOffsetX, 0).setDuration(500).start(); &#125; ObjectAnimator moveIn = ObjectAnimator.ofFloat(mRootView, "translationX", event.getX(), mWindowWidth); moveIn.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); finish(); &#125; &#125;); moveIn.setDuration(500).start(); //反弹回来 &#125; else if (event.getX() &lt; mWindowWidth / 2) &#123; ObjectAnimator.ofFloat(mRootView, "translationX", event.getX(), 0).setDuration(500).start(); if (mBeforeActivity != null) &#123; ObjectAnimator.ofFloat(mBeforeActivity.getRootView(), "translationX", mOffsetX, mOutsideWidth).setDuration(500).start(); &#125; mOffsetX = mOutsideWidth; &#125; &#125; else &#123; mGestureDetector.onTouchEvent(event); &#125; &#125; return true; &#125; /** * 手势监听 */ private class GestureListener extends GestureDetector.SimpleOnGestureListener &#123; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; if (e1 != null) &#123; handlerCurrentActivityScroll(e2); handleBeforeActivityScroll(e2, distanceX); &#125; return super.onScroll(e1, e2, distanceX, distanceY); &#125; /** * 处理当前页面滑动 */ private void handlerCurrentActivityScroll(MotionEvent e2) &#123; isScroll = true; mRootView.setTranslationX(e2.getX()); if (e2.getX() &gt; mWindowWidth - 20) &#123; finish(); &#125; &#125; /** * 处理上一个页面滑动 */ private void handleBeforeActivityScroll(MotionEvent e2, float distanceX) &#123; if (mBeforeActivity != null) &#123; mOffsetX = distanceX &lt; 0 ? mOffsetX + Math.abs(distanceX) / 4 : mOffsetX - Math.abs(distanceX) / 4; if (mOffsetX &gt; 0.0001) &#123; mOffsetX = 0f; &#125; mBeforeActivity.getRootView().setTranslationX(mOffsetX); &#125; &#125; &#125;&#125; 这是我们最终的效果图 DEMO]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android IOC框架实现]]></title>
      <url>%2F2015%2F10%2F01%2FAndroid-IOC%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[什么是IOC？IOC框架称为控制控制反转框架也称为依赖注入框架，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。 IOC相关概念在写一个框架之前，我们需要了解下IOC的相关概念。简单来说，对象和IOC容器的关系就像电脑和外设之间的关系，其中电脑相当于对象，而IOC容器相当于一个个不同的电脑外设。外设具有不同的功能，并且他们和电脑之间都遵循着某种协议（如USB2.0协议），因此它们在彼此独立的同时却又能相互联系。输入功能原本属于电脑的，但是外设键盘却能通过电脑提供的相关接口来控制电脑的输入功能，这就是IOC概念里面的控制反转。由于电脑和外设间都遵循着USB协议，键盘便可以实现随意切换，却不影响键盘的输入功能，这就是IOC概念里面的依赖注入。 好了，了解完IOC协议后，便可以开始绘制相应的架构图了。 IOC框架图 这是我用StartUml绘制的UML图。 如这个图所示，整个IOC框架可以分为5个部分1、ModuleListener，IOC的核心接口，相当于电脑的USB协议2、AbsModule，这就是IOC容器，IOC容器功能都在这个类里面实现3、IOCProxy，对象的静态代理，相当于电脑的USB接口4、ModuleFactory，IOC容器的享元工厂，用于创建IOC容器5、AbsActivity，具体的对象 有了概念，有了图纸，现在终于可以愉快的码代码了 功能实现ModuleListener如上文所说的那样，ModuleListener是整个IOC框架的IOC协议，它本质上就是一个接口，定义了几个方法，仅此而已，是的，所谓的IOC协议就是那么简单。代码如下： 12345678910111213141516171819202122232425public interface ModuleListener &#123; /** * 无参的回调 * * @param method 方法名 */ public void callback(String method); /** * 带参数的回调 * * @param method 方法名 * @param dataClassType 参数类型 * @param data 数据 */ public void callback(String method, Class&lt;?&gt; dataClassType, Object data); /** * 统一接口的回调，回调接口为dataCallback * * @param result 返回码 * @param data 回调数据 */ public void callback(int result, Object data);&#125; AbsModuleAbsModule，这就是IOC框架的IOC容器，IOC容器的功能都应该在它的子类里面实现。AbsModule依赖于ModuleListener接口，它持有ModuleListener的引用。其实说白了它就是一个观察者对象，仅此而已….代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class AbsModule &#123; public String TAG = ""; private Context mContext; private ModuleListener mModuleListener; public AbsModule(Context context) &#123; mContext = context; init(); &#125; /** * 初始化一些东西 */ private void init() &#123; String className = getClass().getName(); String arrays[] = className.split("\\."); TAG = arrays[arrays.length - 1]; &#125; public void setModuleListener(ModuleListener moduleListener) &#123; if (moduleListener == null) throw new NullPointerException("ModuleListener为空"); this.mModuleListener = moduleListener; &#125; public Context getContext() &#123; return mContext; &#125; /** * 统一的回调 * * @param result 返回码 * @param data 回调数据 */ protected void callback(int result, Object data) &#123; mModuleListener.callback(result, data); &#125; /** * module回调 * * @param method 回调的方法名 */ @Deprecated protected void callback(String method) &#123; mModuleListener.callback(method); &#125; /** * 带参数的module回调 * * @param method 回调的方法名 * @param dataClassType 回调数据类型 * @param data 回调数据 */ @Deprecated protected void callback(String method, Class&lt;?&gt; dataClassType, Object data) &#123; mModuleListener.callback(method, dataClassType, data); &#125;&#125; IOCProxy类如其名，IOCProxy本身就是一个静态代理，代理本身其实很简单，说白了，代理就是我们平时所说的“黑中介”，在这里，我们的代理仅仅只实现了两个功能：1、给IOC对象设置观察者，这个观察者是继承于AbsModule的子类。2、中转AbsModule回调的数据，将数据再次回调到AbsActivity的相应接口。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import android.util.Log;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class IOCProxy implements ModuleListener &#123; private static final String TAG = "IOCProxy"; private static final String mMethod = "dataCallback"; private Object mObj; /** * 初始化静态代理 */ public static IOCProxy newInstance(Object obj, AbsModule module) &#123; return new IOCProxy(obj, module); &#125; /** * 被代理对象 */ private IOCProxy(Object obj, AbsModule module) &#123; this.mObj = obj; if (module != null) &#123; module.setModuleListener(this); &#125; &#125; /** * 动态切换不同的观察者 * @param module */ public void changeModule(AbsModule module) &#123; module.setModuleListener(this); &#125; /** * 统一的数据回调 * * @param result 返回码 * @param data 回调数据 */ @Override public void callback(int result, Object data) &#123; synchronized (this) &#123; try &#123; Method m = mObj.getClass().getDeclaredMethod(mMethod, int.class, Object.class); m.setAccessible(true); m.invoke(mObj, result, data); &#125; catch (NoSuchMethodException e) &#123; Log.e(TAG, "无法找到" + mMethod + "方法"); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 数据回调 * * @param method 方法名 */ @Override @Deprecated public void callback(String method) &#123; synchronized (this) &#123; try &#123; Method m = mObj.getClass().getDeclaredMethod(method); m.setAccessible(true); m.invoke(mObj); &#125; catch (NoSuchMethodException e) &#123; Log.e(TAG, "无法找到" + method + "方法"); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 带参数的回调 * * @param method 方法名 * @param dataClassType 参数类型,如 int.class * @param data 数据 */ @Override @Deprecated public void callback(String method, Class&lt;?&gt; dataClassType, Object data) &#123; synchronized (this) &#123; try &#123; Method m = mObj.getClass().getDeclaredMethod(method, dataClassType); m.setAccessible(true); m.invoke(mObj, data); &#125; catch (NoSuchMethodException e) &#123; Log.e(TAG, "无法找到" + method + "方法"); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 在这个类里，博主根据以前的需求写了几种不同的代理回调。但是，我强烈建议你使用带有返回码的统一回调接口，该方法规定了AbsActivity的回调函数，实现了数据流的统一，一致性总归是好的，便于我们后期维护。 ModuleFactoryModuleFactory是一个享元工厂，IOC容器的构建都是由它来完成了，享元实现不同对象的容器之间的共享。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;public class ModuleFactory &#123; private static final String TAG = "ModuleFactory"; private static Map&lt;String, AbsModule&gt; mModules = new HashMap&lt;&gt;(); /** * 获取Module */ protected static &lt;T extends AbsModule&gt; T getModule(Context context, Class&lt;T&gt; clazz) &#123; T module = (T) mModules.get(String.valueOf(clazz.hashCode())); if (module == null) &#123; return newInstanceModule(context, clazz); &#125; return module; &#125; /** * 构造一个新的Module */ private static &lt;T extends AbsModule&gt; T newInstanceModule(Context context, Class&lt;T&gt; clazz) &#123; Class[] paramTypes = &#123;Context.class&#125;; Object[] params = &#123;context&#125;; try &#123; Constructor&lt;T&gt; con = clazz.getConstructor(paramTypes); T module = con.newInstance(params); mModules.put(String.valueOf(clazz.hashCode()), module); return module; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; AbsActivity写了这么久，终于快到尾声了…AbsActivity是IOC框架的对象，Activity也没啥好说的，大家都懂的，直接放代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public abstract class AbsActivity extends AppCompatActivity &#123; private static IOCProxy mProxy; private IOCProxy mNewProxy; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mNewProxy = IOCProxy.newInstance(this, null); &#125; /** * 利用反射来对代理进行重指向 */ private void setProxy() &#123; mProxy = mNewProxy; &#125; /** * 获取Module */ protected static &lt;T extends AbsModule&gt; T getModule(AbsActivity activity, Class&lt;T&gt; clazz) &#123; Method m = ReflectionUtil.getMethod(activity.getClass(), "setProxy", new Class[]&#123;&#125;); try &#123; m.invoke(activity); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; T module = ModuleFactory.getModule(activity, clazz); mProxy.changeModule(module); return module; &#125; /** * 统一的回调接口 * * @param result 返回码，用来判断是哪个接口进行回调 * @param data 回调数据 */ protected abstract void dataCallback(int result, Object data);&#125; 总结到现在为止，框架核心部分已经完成了，现在让我们整理下整个框架到底是怎样运作的！老规矩，还是用图来说明，没什么比图更让人易懂的。下图是整个框架的流程图：图不难懂，我就不废话了，我直接给出例子就行了，大家都是码农，我相信没几个码农喜欢看文字的，都喜欢看代码直接干的。。 例子Module1 1234567891011121314151617181920import android.content.Context;import com.example.yuyu.blogframedemo.frame.AbsModule;/** * Created by yuyu on 2015/9/6. */public class Module1 extends AbsModule&#123; public Module1(Context context) &#123; super(context); &#125; public void module1Test()&#123; callback(100, "我是Module1111111"); &#125; public void cusomCallback()&#123; callback("myCallback", String.class, "我是Module11的自定义回调......"); &#125;&#125; Module2 12345678910111213141516import android.content.Context;import com.example.yuyu.blogframedemo.frame.AbsModule;/** * Created by yuyu on 2015/9/6. */public class Module2 extends AbsModule&#123; public Module2(Context context) &#123; super(context); &#125; public void module2Test()&#123; callback(101, "我是Module22222222"); &#125;&#125; MainActivity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import android.os.Bundle;import android.view.View;import android.widget.Toast;import com.example.yuyu.blogframedemo.R;import com.example.yuyu.blogframedemo.frame.AbsActivity;/** * Created by yuyu on 2015/9/6. */public class MainActivity extends AbsActivity&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; /** * 回调到自定义的方法 * @param data */ private void myCallback(String data)&#123; show(data); &#125; /** * 数据回调，当然你也可以回调到指定的方法里面 * @param result 返回码，用来判断是哪个接口进行回调 * @param data 回调数据 */ @Override protected void dataCallback(int result, Object data) &#123; show(String.valueOf(data)); &#125; public void onClick(View view)&#123; switch (view.getId())&#123; case R.id.module1: getModule(this, Module1.class).module1Test(); break; case R.id.module2: getModule(this, Module2.class).module2Test(); break; case R.id.custom_module: getModule(this, Module1.class).cusomCallback(); break; &#125; &#125; private void show(String msg)&#123; Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); &#125;&#125; DEMOIOC升级版，MVVM框架（实现了6.0权限封装、不需要xml的填充布局、module注入）]]></content>
    </entry>

    
  
  
</search>
